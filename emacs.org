+title: Samuel Michael Vanie's EMACS Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el

* Declare some global variables

Declare some of my variables for my global configuration

#+BEGIN_SRC emacs-lisp
  ;; Making lsp more responsive
  (setq gc-const-threshold (* 25 1000 1000))
  (setq gc-const-percentage (* 70 1000 1000))
  (setq read-process-output-max (* 512 1024)) ;; 1mb

  ;; remove noise for not non allowed command in emacs if your system make them
  (setq ring-bell-function 'ignore)

  ;; Make frame transparency overridable
  (defvar smv/frame-transparency '(90 . 90))

  (setq custom-file (locate-user-emacs-file "custom-vars.el"))
  (load custom-file 'noerror 'nomessage)

  (setq-default indent-tabs-mode nil)
  (set-face-attribute 'default nil :height 159)

  ;; auto refresh buffers when files changes
  (global-auto-revert-mode t)

#+END_SRC


* Scrolling inside popup view

#+begin_src emacs-lisp
;; to scroll down inside the popup
(define-key global-map (kbd "C-M-'")
    (lambda ()
    (interactive)
    (scroll-other-window 2)))

;; to scroll up side the popup
(define-key global-map (kbd "C-M-\"")
 (lambda ()
  (interactive)
  (scroll-other-window-down 2)))

#+end_src

* Package System setup

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages on a new system the first time you pull down your configuration. use-package is a really helpful package used in this configuration to make it a lot easier to automate the installation and configuration of everything else we use.
I don't know why but quelpa doesn't get install automatically (maybe a problem only on mac ?), you should install it manually by running `M-x package-install` then type quelpa

#+BEGIN_SRC emacs-lisp
;; Initialize package sources
(require 'package)
(require 'cl)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                            ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                            ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
    (package-refresh-contents))


;; straight.el section
(defvar bootstrap-version)
(let ((bootstrap-file
      (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
        "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
        'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq straight-use-package-by-default t)

(use-package dired-x
  :straight nil
  :after all-the-icons
  :config
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

(global-set-key [remap dabbrev-expand] 'hippie-expand)

(use-package dashboard
    :config
    (dashboard-setup-startup-hook))

(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+END_SRC


* Keep Folders clean

We use the no-littering package to keep folders where we edit files and the Emacs configuration folder clean! It knows about a wide variety of variables for built in Emacs features as well as those from community packages so it can be much easier than finding and setting these variables yourself.

#+begin_src emacs-lisp

;; NOTE: If you want to move everything out of the ~/.emacs.d folder
;; reliably, set `user-emacs-directory` before loading no-littering!
;(setq user-emacs-directory "~/.cache/emacs")

(use-package no-littering)

;; no-littering doesn't set this by default so we must place
;; auto save files in the same path as it uses for sessions
(setq auto-save-file-name-transforms
      `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

#+end_src
z

* Tree-sitter

#+begin_src emacs-lisp
(use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))

#+end_src

* Shell
** Eshell Ouptut format

User friendly tool that uses Plan9 style interface to show command outputs. These ones are automatically paginates, making it easier to read and analyse them, particularly when dealing with large amouts of data.

#+begin_src emacs-lisp
(require 'em-smart)
(setq eshell-where-to-jump 'begin)
(setq eshell-review-quick-commands nil)
(setq eshell-smart-space-goes-to-end t)
(setq eshell-list-files-after-cd t)

;; Watch out you should have fish installed on your computer
(setq-default explicit-shell-file-name "/opt/homebrew/bin/fish")
(setq eshell-aliases-file "~/.emacs.d/aliases")

(use-package eshell-toggle
    :bind ("C-x C-z" . eshell-toggle))
#+end_src

* Buffers

** Managing buffers easily

#+begin_src emacs-lisp
(defalias 'list-buffers 'ibuffer)
#+end_src

** Kill buffers

I'm writing this function to kill all the buffers because it is really boring to get the confirmation prompt every time you want to kill all the buffers with kill-some-buffers

#+begin_src emacs-lisp
(defun kill-all-buffers ()
  "Kill all buffers without asking for confirmation."
  (interactive)
  (dolist (buffer (buffer-list))
    (kill-buffer buffer)))

(global-set-key (kbd "C-c k a") 'kill-all-buffers)
(global-set-key (kbd "C-k") 'kill-line)
#+end_src

* Basic UI Configuration

This section configures basic UI settings that remove unneeded elements to make Emacs look a lot more minimal and modern.

#+begin_src emacs-lisp

(scroll-bar-mode -1) ; Disable visible scroll bar
(tool-bar-mode -1) ; Disable the toolbar
(tooltip-mode -1) ; Disable tooltips
(set-fringe-mode 10) ; Give some breathing room
(menu-bar-mode -1) ; Disable menu bar


(column-number-mode)
(setq display-line-numbers-type 'relative)
(global-display-line-numbers-mode t) ;; print line numbers for files


;; Set frame transparency
(set-frame-parameter (selected-frame) 'alpha smv/frame-transparency)
(add-to-list 'default-frame-alist `(alpha . ,smv/frame-transparency))
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))

;; Set frame font
(add-to-list 'default-frame-alist '(font . "DaddyTimeMono Nerd Font Mono"))

;; some modes doesn't have to start with lines enable
(dolist (mode '(org-mode-hook
            term-mode-hook
            shell-mode-hook
            eshell-mode-hook))
(add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Font Configuration

** Ligatures

You will need to install the package ligature, because it cannot be installed automatically. Use the command ~package-install~ and search for ligature.

#+begin_src emacs-lisp
(use-package ligature
    :config
    ;; Enable all JetBrains Mono ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
                                        "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
                                        "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
                                        "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
                                        "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
                                        "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
                                        ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
                                        "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
                                        "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
                                        "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
                                        "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src

** Adding color to delimiters

Rainbow permits to match pairs delimiters with the same color.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
	     :hook (prog-mode . rainbow-delimiters-mode))
#+end_src


* Terminal

** Eshell

#+begin_src emacs-lisp
(require 'ansi-color)
(require 'eshell)
(defun eshell-handle-ansi-color ()
  (ansi-color-apply-on-region eshell-last-output-start
                              eshell-last-output-end))
(add-to-list 'eshell-output-filter-functions 'eshell-handle-ansi-color)
#+end_src

** vterm

Vterm is a better terminal emulator that will permit good rendering of all terminal commands

#+begin_src emacs-lisp
  (use-package vterm)

  (use-package multi-vterm
    :after vterm 
    :ensure t
    :bind (("C-c v n" . multi-vterm-project)
           ("C-c v r" . multi-vterm-rename-buffer)
           ("C-c v d" . multi-vterm-dedicated-toggle))
    :config
    (define-key vterm-mode-map [return]                      #'vterm-send-return))
#+end_src


* Keybindings Configuration

** hydra and general

#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

(use-package general ;; for setting keybindings
    :config
    (general-create-definer smv/leader-keys
        :keymaps '(normal visual emacs)
        :prefix "SPC"
        :global-prefix "SPC")

    (smv/leader-keys
        "t" '(:ignore t :which-key "toggles")
        "tt" '(counsel-load-theme :which-key "choose theme")))
    
(use-package hydra) ;; hydra permit to repeat a command easily without repeating the keybindings multiple
#+end_src


** Repeat-mode

#+begin_src emacs-lisp
(use-package repeat
    :ensure nil
    :hook (after-init . repeat-mode)
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 5))
#+end_src


** Ace-jump mode

Permit to quickly go to a character in emacs

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :bind
    ("C-c SPC" . ace-jump-mode))
#+end_src


** Surround

I really loved working with evil-surround or surround of vim. This package mimics that.

#+begin_src emacs-lisp
  (use-package surround
    :ensure t
    :bind-keymap ("C-c s" . surround-keymap))
#+end_src


** Windmonve

This package permits to quickly move between windows in emacs with easy and intuitive bindings. It's built-in to emacs, but you should configure its default bindings by calling the windmove-default-keybinds function.


#+begin_src emacs-lisp
  (use-package windmove
    :ensure nil
    :config
    (windmove-default-keybindings))
#+end_src




** Expand-region

Permits to quickly expand to portions of texts by semantic blocks.


#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src


* UI Configuration

** Color Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] and ef  are a set of themes that support various emacs modes. It also has support for doom-modeline that I use as my mode line.
Counsel can permit quickly switch between these themes, hit ~M-x counsel-load-theme~

#+begin_src emacs-lisp
(use-package doom-themes)
(use-package ef-themes
    :config
    (load-theme 'manoj-dark t))
#+end_src

** Better Mode line

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich mode line configuration for emacs. I use nerd-icons packages to add to it some cool icons.
You will have to install the icons on your machine before to get the full functionnalities : ~M-x all-the-icons-install-fonts~ and ~M-x nerd-icons-install~.

#+begin_src emacs-lisp
  (use-package all-the-icons
      :if (display-graphic-p))

  (use-package all-the-icons-ivy
    :after all-the-icons)

  (use-package all-the-icons-dired
    :after all-the-icons)

  (use-package nerd-icons)
#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]]  is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix. For example, if you press C-c (hold control and press the letter c), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
(use-package which-key ;; print next keybindings
	     :init (which-key-mode) ;; happens before the package is loaded
	     :diminish which-key-mode
	     :config ;; only runs after the mode is loaded
	     (setq which-key-idle-delay 0.3))
#+end_src

** Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]]  is an excellent completion framework for Emacs. It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs. Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]]  adds extra columns to a few of the Counsel commands to provide more information about each item.

#+begin_src emacs-lisp

(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
          :map ivy-minibuffer-map
          ("TAB" . ivy-alt-done)
          ("C-l" . ivy-alt-done)
          ("C-j" . ivy-next-line)
          ("C-k" . ivy-previous-line)
          :map ivy-switch-buffer-map
          ("C-k" . ivy-previous-line)
          ("C-l" . ivy-done)
          ("C-d" . ivy-switch-buffer-kill)
          :map ivy-reverse-i-search-map
          ("C-k" . ivy-previous-line)
          ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

(use-package ivy-rich
  :after (ivy counsel)
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("C-M-j" . 'counsel-switch-buffer)
          :map minibuffer-local-map
          ("C-r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (counsel-mode 1))
#+end_src

*** Improved Candidate Sorting with prescient.el

[[https://github.com/radian-software/prescient.el][prescient.el]] provides some helpful behavior for sorting Ivy completion candidates based on how recently or frequently you select them. This can be especially helpful when using M-x to run commands that you don’t have bound to a key but still need to access occasionally.

#+begin_src emacs-lisp

(use-package ivy-prescient
  :after counsel
  :custom
  (ivy-prescient-enable-filtering nil)
  :config
  ;; Uncomment the following line to have sorting remembered across sessions!
  ;(prescient-persist-mode 1)
  (ivy-prescient-mode 1))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs’ describe- command buffers. For example, if you use describe-function, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

(use-package helpful
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))

#+end_src


** Text Scaling

I use hydra to build a trasient that will permit me to quickly adjust the scale of my text. I boud it to `C-s t s`, and once activated, j and k to increase and decrease the text size.

#+begin_src emacs-lisp

(defhydra hydra-text-scale (:timeout 3)
  "scalte text"
  ("j" text-scale-increase "in")
  ("k" text-scale-decrease "out")
  ("f" nil "finished" :exit t))

(smv/leader-keys ;; use general to set a keybinding to quickly change text size
  "ts" '(hydra-text-scale/body :which-key "scale text"))
#+end_src


* Org Mode

[[https://orgmode.org/][OrgMode]] is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.


** Setting env for pdf export

#+begin_src emacs-lisp
(setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))
#+end_src


** Better Font Faces

I create a function called `smv/org-font-setup` to configure various text faces for tweaking org-mode. I have fixed font for code source, table, ... and variable font (Roboto Condensed light for text).

#+begin_src emacs-lisp

(defun smv/org-font-setup ()
    (font-lock-add-keywords 'org-mode ;; Change the list icon style from "-" to "."
                            '(("^ *\\([-]\\) "
                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([+]\\) "
                            (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))

    ;; configuration of heading levels size
    (dolist (face '((org-level-1 . 1.2)
                        (org-level-2 . 1.1)
                        (org-level-3 . 1.05)
                        (org-level-4 . 1.0)
                        (org-level-5 . 1.0)
                        (org-level-6 . 1.0)
                        (org-level-7 . 1.0)
                        (org-level-8 . 1.0)))
        (set-face-attribute (car face) nil :font "Chalkboard" :weight 'regular :height (cdr face)))
        ;; Ensure that anything that should be fixed-pitch in Org files appears that way
        (set-face-attribute 'org-block nil    :inherit 'fixed-pitch)
        (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
        (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
        (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
        (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
        (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
        (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
        (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))

#+end_src


** Basic Config

This section contains the basic configuration for org-mode plus the configuration for Org agendas and capture templates

#+begin_src emacs-lisp

  (defun smv/org-mode-setup()
      (org-indent-mode)
      (variable-pitch-mode 1)
      (auto-fill-mode 0)
      (visual-line-mode 1)
      (smv/org-font-setup))


  (use-package org ;; org-mode, permit to take notes and other interesting stuff with a specific file extension
      :straight org-contrib
      :hook (org-mode . smv/org-mode-setup)
      :config
      (setq org-ellipsis " ▼:")
      (setq org-agenda-start-with-log-mode t)
      (setq org-log-done 'time)
      (setq org-log-into-drawer t)

      (setq org-agenda-files
              '("~/.org/todo.org"
              "~/.org/projects.org"))

      (setq org-todo-keywords
              '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
              (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

      ;; easily move task to another header
      (setq org-refile-targets
              '(("archive.org" :maxlevel . 1)
              ("todo.org" :maxlevel . 1)
              ("projects.org" :maxlevel . 1)))

      ;; Save Org buffers after refiling!
      (advice-add 'org-refile :after 'org-save-all-org-buffers)

      (setq org-tag-alist
          '((:startgroup)
              ; Put mutually exclusive tags here
              (:endgroup)
              ("@school" . ?s)
              ("personal" . ?p)
              ("note" . ?n)
              ("idea" . ?i)))

      (setq org-agenda-custom-commands
          '(("d" "Dashboard"
          ((agenda "" ((org-deadline-warning-days 7)))
          (todo "TODO"
              ((org-agenda-overriding-header "All tasks")))))

          ("n" "Next Tasks"
          ((todo "NEXT"
              ((org-agenda-overriding-header "Next Tasks")))))

          ("st" "School Todos" tags-todo "+@school/TODO")
          ("sp" "School Projects" tags-todo "+@school/ACTIVE")
          
          ("pt" "Personal Todos" tags-todo "+personal/TODO")
          ("pl" "Personal Projects" tags-todo "+personal/ACTIVE")
          
          ;; Low-effort next actions
          ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
          ((org-agenda-overriding-header "Low Effort Tasks")
          (org-agenda-max-todos 20)
          (org-agenda-files org-agenda-files)))))

      (setq org-capture-templates ;; quickly add todos entries without going into the file
          `(("t" "Tasks")
          ("tt" "Task" entry (file+olp "~/.org/todo.org" "Tasks")
                  "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)))


      (smv/org-font-setup)
      (global-set-key (kbd "C-c a") 'org-agenda)
      (global-set-key (kbd "M-i") 'org-insert-item))


  ;; Install htmlize for source block hightlighting
  (use-package htmlize
    :after org)
#+end_src


** Auto rendering latex section

#+begin_src emacs-lisp
(use-package org-fragtog
    :hook (org-mode-hook . org-fragtog-mode))
#+end_src

** Presentation

Permet de faire des slides de presentation stylees dans le web sous emacs.

Apparemment il est possible de set la variable =(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")= au lieu de telecharger le CDN.

#+begin_src emacs-lisp
(use-package ox-reveal)
(setq Org-Reveal-root "~/.config/emacs/reveal-js")
(setq Org-Reveal-title-slide nil)
#+end_src


** Nicer Heading

[[https://github.com/sabof/org-bullets][org-bullets]] permits to change the icon used for the different headings in org-mode.

I use also `org-num` to add numbers in front of my different headlines.

#+begin_src emacs-lisp

(use-package org-bullets ;; change the bullets in my org mode files
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "☯" "○" "☯" "✸" "☯" "✿" "☯" "✜" "☯" "◆" "☯" "▶")))

;; Outline numbering for org mode
(use-package org-num
    :straight nil
    :load-path "lisp/"
    :after org
    :hook (org-mode . org-num-mode))
#+end_src


** Configure Babel Languages

To execute or export code in org-mode code blocks, you’ll need to set up org-babel-load-languages for each language you’d like to use. [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with org-babel.

#+begin_src emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
      (python . t)))

  (push '("conf-unix" . conf-unix) org-src-lang-modes))
#+end_src


** Structure Templates

Org mode's [[https://orgmode.org/manual/Structure-Templates.html][structure template]] feature enables you to quickly insert code blocks into your Org files in combination with `org-tempo` by typing `<` followed by the template name like `el` or `py` and then press `TAB`. For example, to insert an empy `emacs-lisp` block below, you can type `<el` and press `TAB` to expand into such a block.

#+begin_src emacs-lisp
(with-eval-after-load 'org
;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("ru" . "src rust")))
#+end_src


** Auto-tangle Configuration files

This snippets adds a hook to `org-mode` buffers so that efs/org-babel-tangle-config gets executed each time such a buffer gets saved. This function checks to see if the file being saved is the Emacs.org file you’re looking at right now, and if so, automatically exports the configuration here to the associated output files. Tangle is use to export org mode files into the configuration init.el file.

#+begin_src emacs-lisp

;; Automatically tangle our Emacs.org config file when we save it
(defun smv/org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.config/emacs/emacs.org"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'smv/org-babel-tangle-config)))

#+end_src



* Development

** Undo tree

Some day undo tree saved my self from losing my progress. It shows the changes history as a tree that you can freely explore

#+begin_src emacs-lisp
(use-package undo-tree
  :config
  (global-undo-tree-mode))
#+end_src

** Commenting Code

To help me comment code region quickly I set up this keyboard shortcut. The function used is a native emacs function.

#+begin_src emacs-lisp
(global-set-key (kbd "C-M-;") 'comment-region)
#+end_src


** Search project wide

Wgrep will permit to make grep buffers editable so that you can just modify the occurences of what you're looking for.
I use the built-in rgrep to do my search and replace so I'm binding it to =C-c r= .
#+begin_src emacs-lisp
(use-package wgrep)
(global-set-key (kbd "C-c r") 'rgrep)
#+end_src


** Direnv

direnv permit to load environment on fly. You will need to have a .envrc file, you could generate it with =lorri init= command or you can create one with the =use flake= command in it if you're using flakes.

To use this plugin you must install direnv using :  =nix-env -i direnv=. You can also install lorri the same way.

You could go to the lorri's website to grab some info [[https://github.com/nix-community/lorri][lorri website]]

#+begin_src emacs-lisp
(use-package direnv
  :config
  (direnv-mode))
#+end_src


** Languages

*** IDE Features with eglot-mode

Language server configuration for programming part.
eglot is installed by default so just chill and be happy with it.
I use some useful lsp packages with downloaded languages server for my programming journey.


**** Flymake

Flymake is the built-in inline diagnostic tool used by eglot.

#+begin_src emacs-lisp
  (use-package flymake
    :bind
    ("M-g f l" . flymake-show-project-diagnostics))

  (global-set-key (kbd "M-g e a") 'eglot-code-actions)
#+end_src


**** markdown-mode

I use this to make the eglot documentation more pretty

#+begin_src emacs-lisp
(use-package markdown-mode)
#+end_src


**** yasnippet

Useful snippets for quick programming

#+begin_src emacs-lisp
  (use-package yasnippet
      :config (yas-global-mode))

  (use-package auto-yasnippet
    :bind
    ("C-c C-y w" . aya-create)
    ("C-c C-y TA". aya-expand)
    ("C-c C-y SP". aya-expand-from-history)
    ("C-c C-y d" . aya-delete-from-history)
    ("C-c C-y c" . aya-clear-history)
    ("C-c C-y n" . aya-next-in-history)
    ("C-c C-y p" . aya-previous-in-history)
    ("C-c C-y s" . aya-persist-snippet)
    ("C-c C-y o" . aya-open-line))

#+end_src


*** Yaml-mode

Mode for yaml configuration files editing.

#+begin_src emacs-lisp
(use-package yaml-mode
:mode (("\\.yml\\'" . yaml-mode)
            ("\\.yaml\\'" . yaml-mode)
            ))
#+end_src



*** Nix mode

You know about nix ? This package manager... This mode permit to write file in the nix programming language.

#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode ("\\.nix\\'" . nix-ts-mode))
#+end_src



*** Clojure

I love this programming language, just started to learn it.

#+begin_src emacs-lisp
(use-package cider)
(use-package clojure-ts-mode
  :mode ("\\.clj\\'" . clojure-ts-mode)
  :hook (clojure-ts-mode . eglot-ensure))
#+end_src

*** Web Programming

**** Emmet-mode

Emmet mode allors you to easily expand html and css abbreviations for instance if I type "p" then press control and j I get <p></p>. You can also use things like ~".container>section>(h1+p)"~.

#+begin_src emacs-lisp
(use-package emmet-mode)
#+end_src

**** Web-mode

The useful web mode for programming.

#+begin_src emacs-lisp

(defun smv/web-mode-hook ()
"Hooks for Web mode."
(setq web-mode-markup-indent-offset 2)
(setq web-mode-css-indent-offset 2)
(setq web-mode-code-indent-offset 2)
(setq web-mode-enable-current-column-highlight t)
(setq web-mode-enable-current-element-highlight t)
(set (make-local-variable 'company-backends) '(company-css company-web-html company-yasnippet company-files))
)

(use-package web-mode
    :mode (("\\.html?\\'" . web-mode)
            ("\\.css?\\'" . web-mode)
            )
    :hook
    (web-mode . smv/web-mode-hook)
    (web-mode . emmet-mode)
    (web-mode . prettier-mode)
)

(add-hook 'web-mode-before-auto-complete-hooks
    '(lambda ()
    (let ((web-mode-cur-language
            (web-mode-language-at-pos)))
                (if (string= web-mode-cur-language "php")
            (yas-activate-extra-mode 'php-mode)
        (yas-deactivate-extra-mode 'php-mode))
                (if (string= web-mode-cur-language "css")
            (setq emmet-use-css-transform t)
        (setq emmet-use-css-transform nil)))))

#+end_src


**** JSX support

#+begin_src emacs-lisp
(use-package rjsx-mode
  :mode (("\\.js\\'" . rjsx-mode)
            ("\\.ts\\'" . rjsx-mode))
  :hook
  (rjsx-mode . emmet-mode)
  (rjsx-mode . prettier-mode))
#+end_src

**** prettier

Prettier automatically formats the code for you. I hate when it's in other modes but in web mode it's quite useful.

#+begin_src emacs-lisp
(use-package prettier)
#+end_src

*** TypeScript

You will need to install typescript-language-server with `npm install -g typescript-language-server typescript` .

#+begin_src emacs-lisp

(use-package typescript-mode
    :mode "\\.ts\\'"
    :config
    (setq typescript-indent-level 2))
#+end_src

*** PHP

Installing PHP

#+begin_src emacs-lisp
(use-package php-mode
:hook (php-mode . eglot-ensure)
:mode "\\.php\\'")
#+end_src


*** JAVA

You would have to set the path to JDTserver

#+begin_src emacs-lisp
(use-package eglot-java
    :after eglot)
#+end_src

*** R

#+begin_src emacs-lisp
;;(use-package ess)
#+end_src

*** RUST

#+begin_src emacs-lisp
(use-package rust-mode)

(use-package rust-ts-mode
  :hook (rust-ts-mode . eglot-ensure)
  :mode "\\.rs\\'"
  :bind-keymap
  ("C-c c" . rust-mode-map))

#+end_src

*** DART & FLUTTER

#+begin_src emacs-lisp
(use-package flutter)

(use-package dart-mode
    :hook (dart-mode . eglot-ensure)
    :mode "\\.dart\\'")
#+end_src


** Debugger configuration

#+begin_src emacs-lisp
(use-package dape)
#+end_src

** Company Mode

Company Mode provides a nicer in-buffer completion interface than completion-at-point which is more reminiscent of what you would expect from an IDE. We add a simple configuration to make the keybindings a little more useful (TAB now completes the selection and initiates completion at the current location if needed).

#+begin_src emacs-lisp
(use-package company
    :after eglot-mode
    :hook (eglot-managed-mode . company-mode)
    :bind
    (:map company-mode
        ("M-o" . company-manual-begin))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

(use-package company-box
    :hook
    (company-mode . company-box-mode))

(use-package company-tabnine
    :config
    (add-to-list 'company-backends #'company-tabnine t))
#+end_src


** Docker Mode

Quickly manages [[https://github.com/Silex/docker.el][docker]] container directly inside emacs.

#+begin_src emacs-lisp
(use-package docker
    :bind ("C-c d" . docker))

(use-package dockerfile-mode)
#+end_src


** Github Copilot

Using github copilot has my pair programming assistant to finish my tasks more quickly.
Uncomment the commented parts only when you will finish installing copilot.

#+begin_src emacs-lisp
  (use-package copilot
    :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
    :ensure t)

  (setq copilot-node-executable "/opt/homebrew/bin/node")

  ;; keybindings that are active when copilot shows completions
  (define-key copilot-mode-map (kbd "C-M-<next>") #'copilot-next-completion)
  (define-key copilot-mode-map (kbd "C-M-<prior>") #'copilot-previous-completion)
  (define-key copilot-mode-map (kbd "C-M-<right>") #'copilot-accept-completion-by-word)
  (define-key copilot-mode-map (kbd "C-M-<return>") #'copilot-accept-completion-by-line)
  (define-key copilot-mode-map (kbd "C-M-<down>") 'copilot-accept-completion)

#+end_src


** Magit

[[https://magit.vc/][Magit]] is a git interface for emacs. It's very handy and fun to use.

#+begin_src emacs-lisp
(use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src
