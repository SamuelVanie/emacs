#+title: Samuel Michael Vanie's EMACS Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el


* Declare some global variables

#+begin_src emacs-lisp
  (setq gc-const-threshold (* 90 1000 1000))
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z"))
  (setopt use-short-answers t)

  (setq warning-minimum-level :error)
  (global-hl-line-mode 1)

  (cond
   ((eq system-type 'darwin)  ;; macOS
    (setq read-process-output-max (* 64 1024)))  ;; 64KB
   ((eq system-type 'gnu/linux)  ;; Linux
    (setq read-process-output-max (* 1024 1024)))  ;; 1MB
   )

  (cond
   ((eq system-type 'darwin)
    (defvar smv/default-font-size 180)
    (defvar smv/default-variable-font-size 180))
   ((eq system-type 'gnu/linux)
    (defvar smv/default-font-size 139)
    (defvar smv/default-variable-font-size 139))
   )

  ;; remove noise for not non allowed command in emacs if your system make them
  (setq ring-bell-function 'ignore)

  (setq custom-file (locate-user-emacs-file "custom-vars.el"))
  (load custom-file 'noerror 'nomessage)

  ;; prevent emacs from hanging on when long lines are present in the current file
  (global-so-long-mode t)

  ;; auto refresh buffers when files changes
  (global-auto-revert-mode t)
  (global-visual-line-mode t)

  ;; Prevent dired-find-alternative warning message
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

* Scrolling

** Scrolling inside pop-up view

#+begin_src emacs-lisp
  ;; to scroll down inside the popup
  (define-key global-map (kbd "C-M-'")
              (lambda ()
                (interactive)
                (scroll-other-window 2)))

  ;; to scroll up side the popup
  (define-key global-map (kbd "C-M-\"")
              (lambda ()
                (interactive)
                (scroll-other-window-down 2)))
#+end_src


* Package System setup

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages on a new system the first time you pull down your configuration. use-package is a really helpful package used in this configuration to make it a lot easier to automate the installation and configuration of everything else we use.
I don't know why but quelpa doesn't get install automatically (maybe a problem only on mac ?), you should install it manually by running `M-x package-install` then type quelpa

#+BEGIN_SRC emacs-lisp

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          (or (bound-and-true-p straight-base-dir)
              user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))


  (straight-use-package 'use-package)

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)

  (setq read-file-name-completion-ignore-case t)
  (setq hippie-expand-try-functions-list
        '(
          try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          ;; try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol
          try-complete-file-name-partially
          try-expand-line-all-buffers
          ))

  (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+END_SRC




* Tree-sitter

#+begin_src emacs-lisp
  (use-package treesit-auto
    :straight t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src


* Shell

** Getting the exec path from shell

This is a package that will permit to have the same exec-path as my $PATH shell variable so that all of my packages are available.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (use-package exec-path-from-shell
        :straight t
        :init
        (exec-path-from-shell-initialize)))
#+end_src

** Eshell Ouptut format

User friendly tool that uses Plan9 style interface to show command outputs. These ones are automatically paginates, making it easier to read and analyse them, particularly when dealing with large amouts of data.

#+begin_src emacs-lisp
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  (setq eshell-list-files-after-cd t)

  ;; Watch out you should have fish installed on your computer
  (setq eshell-aliases-file (format "%s%s" user-emacs-directory "aliases"))
  (global-set-key (kbd "C-c e") 'eshell)
#+end_src


* Buffers

** Managing buffers easily

#+begin_src emacs-lisp
  ;; this will make emacs ibuffer the default used to list buffers
  (defalias 'list-buffers 'ibuffer)

  ;; Ibuffer appearance configuration
  (setq ibuffer-use-other-window t)

  (defun my-both-modes-active-p (buffer-name action)
    "Return non-nil if buffer is org-mode with gptel active."
    (with-current-buffer buffer-name
      (and (derived-mode-p 'org-mode)
           (bound-and-true-p gptel-mode))))

  (add-to-list 'display-buffer-alist
               '("\\*Ibuffer\\*"
                 (display-buffer-in-side-window)
                 (window-height . 0.4)     ;; Takes 40% of the frame height
                 (side . bottom)           ;; Display at bottom
                 (slot . 0)))
#+end_src

** Kill buffers

I'm writing this function to kill all the buffers because it is really boring to get the confirmation prompt every time you want to kill all the buffers with kill-some-buffers

#+begin_src emacs-lisp
  (defun kill-all-buffers ()
    "Kill all buffers without asking for confirmation."
    (interactive)
    (dolist (buffer (buffer-list))
      (kill-buffer buffer)))

  (global-set-key (kbd "C-c k a") 'kill-all-buffers)
  (global-set-key (kbd "C-k") 'kill-line)
#+end_src


** Popper

A package that permits to transform some buffers into popups. Quite useful to quickly go back and forth on those buffers.

#+begin_src emacs-lisp
  (use-package popper
    :straight t ; or :straight t
    :bind (("C-`"   . popper-toggle)
           ("C-M-`"   . popper-cycle)
           ("M-`" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode
  	  agent-shell-mode
            (lambda (buf) (with-current-buffer buf
                            (bound-and-true-p gptel-mode)))))
    (setq popper-window-height "40")
    (setq popper-display-control nil)
    ;; Match eshell, shell, term and/or vterm buffers
    (setq popper-reference-buffers
  	(append popper-reference-buffers
  		'("^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
  		  "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
  		  "^\\*term.*\\*$"   term-mode   ;term as a popup
  		  "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup
                    "^\\*eat.*\\*$"    eat-mode    ;eat as a popup
                    )))

    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

* Basic UI Configuration

This section configures basic UI settings that remove unneeded elements to make Emacs look a lot more minimal and modern.

#+begin_src emacs-lisp

  (scroll-bar-mode -1) ; Disable visible scroll bar
  (tool-bar-mode -1) ; Disable the toolbar
  (tooltip-mode -1) ; Disable tooltips
  (set-fringe-mode 10) ; Give some breathing room
  (menu-bar-mode -1) ; Disable menu bar

  (column-number-mode)
  (global-display-line-numbers-mode t) ;; print line numbers for files


  ;; Set frame transparency
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))



  ;; some modes doesn't have to start with lines enable
  (dolist (mode '(
                  term-mode-hook
                  doc-view-minor-mode-hook
                  gptel-mode-hook
                  shell-mode-hook
                  dired-mode-hook
                  vterm-mode-hook
  		agent-shell-mode-hook
                  eat-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () 
                     (display-line-numbers-mode 0)
                     (setq-local global-hl-line-mode nil))))

#+end_src



** Font Configuration

I use DaddyTimeMono Nerd Font as my main font for both fixed and variable fonts.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (progn
        (set-frame-font "VictorMono Nerd Font-19" nil t)
        (set-face-attribute 'fixed-pitch nil :family "FantasqueSansM Nerd Font Mono"))
    (add-to-list 'default-frame-alist '(font . "VictorMono Nerd Font-15"))
    (set-face-attribute 'fixed-pitch nil :family "FantasqueSansM Nerd Font"))

  (set-face-attribute 'variable-pitch nil :family "Iosevka Nerd Font")
  ;; (set-face-attribute 'variable-pitch nil :family "FantasqueSansM Nerd Font")
#+end_src


** Adding color to delimiters

Rainbow permits to match pairs delimiters with the same color.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Indentation configuration

#+begin_src emacs-lisp
  ;; a function to highlight indentation
  (use-package highlight-indent-guides
    :straight t
    :config
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    (setq highlight-indent-guides-auto-character-face-perc 95)
    (setq highlight-indent-guides-method 'character)
    )

  ;; Indentation based on the indentation of the previous non-blank line.
  (setq-default indent-line-function #'indent-relative-first-indent-point)

  ;; In modes such as `text-mode', pressing Enter multiple times removes
  ;; the indentation. The following fixes the issue and straights that text
  ;; is properly indented using `indent-relative' or
  ;; `indent-relative-first-indent-point'.
  (setq-default indent-line-ignored-functions '())
  (global-set-key (kbd "C-<tab>") 'tab-to-tab-stop)
  #+end_src

* Keybindings Configuration

** Hydra and general

#+begin_src emacs-lisp
  (use-package hydra
    :straight t) ;; hydra permit to repeat a command easily without repeating the keybindings multiple
  (use-package general
    :straight t) ;; permit to define bindings under another one easily
#+end_src

** Repeat Mode

Allows me te repeat bindings by typing the last character multiple times.

#+begin_src emacs-lisp
  (use-package repeat
    :straight nil
    :hook (after-init . repeat-mode)
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 5))
#+end_src


** Meow-mode

Trying the modal editor meow

#+begin_src emacs-lisp
  (defun smv/remove-overlays ()
    (interactive)
    (remove-overlays))

  (defun smv/surround-with-pair (open close)
    "Surround the active region or insert pair at point using insert-pair.
          OPEN is the opening character, CLOSE is the closing character."
    (interactive)
    (if (use-region-p)
        (insert-pair 1 open close)
      (insert-pair nil open close)))


  (defun smv/surround-custom ()
    "Prompt for custom opening and closing characters to surround text."
    (interactive)
    (let ((open (read-char "Opening character: "))
          (close (read-char "Closing character: ")))
      (smv/surround-with-pair open close)))


  (defun smv/surround-with-string (open-str close-str)
    "Surround region or point with arbitrary strings."
    (if (use-region-p)
        (let ((beg (region-beginning))
              (end (region-end)))
          (goto-char end)
          (insert close-str)
          (goto-char beg)
          (insert open-str))
      (insert open-str close-str)
      (backward-char (length close-str))))

  (with-eval-after-load 'hydra
    (defhydra hydra-surround (:color blue :hint nil)
      "Surround region with

      ^Quotes^          ^Brackets^        ^Symbols^         ^Custom^
      ^^^^^^^^--------------------------------------------------------
      _\"_: double       _(_: parentheses  _<_: angles       _c_: custom pair
      _'_: single        _[_: square       _`_: backticks    _t_: HTML tag
      _~_: tilde         _{_: curly        _*_: asterisks    _s_: custom strings
                                         _=_: equals
                                         _+_: plus
      "
      ("\"" (smv/surround-with-pair ?\" ?\"))
      ("'" (smv/surround-with-pair ?' ?'))
      ("~" (smv/surround-with-pair ?~ ?~))
      ("(" (smv/surround-with-pair ?\( ?\)))
      ("[" (smv/surround-with-pair ?\[ ?\]))
      ("{" (smv/surround-with-pair ?\{ ?\}))
      ("<" (smv/surround-with-pair ?\< ?\>))
      ("`" (smv/surround-with-pair ?` ?`))
      ("*" (smv/surround-with-pair ?* ?*))
      ("=" (smv/surround-with-pair ?= ?=))
      ("+" (smv/surround-with-pair ?+ ?+))
      ("c" smv/surround-custom)
      ("s" (let ((open (read-string "Opening string: "))
                 (close (read-string "Closing string: ")))
             (smv/surround-with-string open close)))
      ("q" nil "quit" :color red))
    )


  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-colemak)


    (meow-motion-define-key
     '("<escape>" . ignore)
     '("e" . meow-next)
     '("u" . meow-prev)
     '("n" . meow-left)
     '("s" . meow-insert)
     '("i" . meow-right)
     '("m" . meow-mark-word)
     '("M" . meow-mark-symbol)
     '("J" . hydra-surround/body)
     '("C" . meow-pop-to-mark)
     '("V" . meow-unpop-to-mark)
     '("<" . previous-buffer)
     '("<home>" . meow-temp-normal)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '(">" . next-buffer)
     '("K" . kill-current-buffer)
     )

    (meow-leader-define-key
     '("?" . meow-cheatsheet)
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("SPC" . smv/remove-overlays))

    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("1" . meow-expand-1)
     '("2" . meow-expand-2)
     '("3" . meow-expand-3)
     '("4" . meow-expand-4)
     '("5" . meow-expand-5)
     '("6" . meow-expand-6)
     '("7" . meow-expand-7)
     '("8" . meow-expand-8)
     '("9" . meow-expand-9)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("}" . forward-paragraph)
     '("{" . backward-paragraph)
     '("/" . meow-visit)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("C" . meow-pop-to-mark)
     '("d" . duplicate-line)
     '("D" . delete-pair)
     '("e" . meow-next)        ;; Down (next line)
     '("E" . meow-prev-expand)
     '("f" . meow-find)
     '("F" . yank-media)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("H" . meow-left-expand)
     '("i" . meow-right) ;; Right (forward char)
     '("I" . meow-right-expand)
     '("j" . meow-join)
     '("J" . hydra-surround/body)
     '("k" . meow-kill)
     '("K" . kill-current-buffer)
     '("l" . meow-line)
     '("L" . meow-visual-line)
     '("m" . meow-mark-word)
     '("M" . meow-mark-symbol)
     '("n" . meow-left) ;; Left (backward char)
     '("N" . meow-next-expand)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("P" . meow-yank-pop)
     '("q" . meow-quit)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-insert)
     '("S" . meow-open-above)
     '("t" . meow-till)
     '("u" . meow-prev)        ;; Up (prev line)
     '("U" . meow-undo)        ;; Undo moved to U
     '("v" . meow-search)
     '("V" . meow-unpop-to-mark)
     '("w" . meow-next-word)
     '("W" . meow-next-symbol)
     '("x" . meow-delete)
     '("X" . meow-backward-delete)
     '("y" . meow-save)
     '("Y" . copy-from-above-command)
     '("z" . meow-pop-selection)
     '("<" . previous-buffer)
     '(">" . next-buffer)
     '("<escape>" . ignore)))

  (defun meow--tag-find-bounds ()
    "Find bounds of the current HTML/XML tag.
  Returns (BEG . END) cons cell or nil if not found."
    (save-excursion
      (let ((start-pos (point))
            opening-tag-start
            opening-tag-end
            closing-tag-start
            closing-tag-end
            tag-name)
        
        ;; Try to find if we're inside a tag
        ;; First, look backward for opening tag
        (when (re-search-backward "<\\([[:alnum:]:_-]+\\)[^>]*>" nil t)
          (setq opening-tag-start (match-beginning 0))
          (setq opening-tag-end (match-end 0))
          (setq tag-name (match-string 1))
          
          ;; Now search forward for the matching closing tag
          (let ((depth 1))
            (goto-char opening-tag-end)
            (while (and (> depth 0)
                        (re-search-forward 
                         (concat "</?\\(" (regexp-quote tag-name) "\\)[^>]*>") 
                         nil t))
              (if (string= (substring (match-string 0) 0 2) "</")
                  (setq depth (1- depth))
                ;; Check if it's not a self-closing tag
                (unless (string= (substring (match-string 0) -2) "/>")
                  (setq depth (1+ depth))))
              (when (= depth 0)
                (setq closing-tag-end (match-end 0))
                (setq closing-tag-start (match-beginning 0)))))
          
          ;; Verify the original position is within bounds
          (when (and closing-tag-end
                     (>= start-pos opening-tag-start)
                     (<= start-pos closing-tag-end))
            (cons opening-tag-start closing-tag-end))))))

  (defun meow--tag-find-inner ()
    "Find inner bounds of the current HTML/XML tag (content only).
  Returns (BEG . END) cons cell or nil if not found."
    (save-excursion
      (let ((start-pos (point))
            opening-tag-start
            opening-tag-end
            closing-tag-start
            tag-name)
        
        ;; Find opening tag
        (when (re-search-backward "<\\([[:alnum:]:_-]+\\)[^>]*>" nil t)
          (setq opening-tag-start (match-beginning 0))
          (setq opening-tag-end (match-end 0))
          (setq tag-name (match-string 1))
          
          ;; Find matching closing tag
          (let ((depth 1))
            (goto-char opening-tag-end)
            (while (and (> depth 0)
                        (re-search-forward 
                         (concat "</?\\(" (regexp-quote tag-name) "\\)[^>]*>") 
                         nil t))
              (if (string= (substring (match-string 0) 0 2) "</")
                  (setq depth (1- depth))
                (unless (string= (substring (match-string 0) -2) "/>")
                  (setq depth (1+ depth))))
              (when (= depth 0)
                (setq closing-tag-start (match-beginning 0)))))
          
          ;; Verify position is within bounds and return inner content
          (when (and closing-tag-start
                     (>= start-pos opening-tag-end)
                     (<= start-pos closing-tag-start))
            (cons opening-tag-end closing-tag-start))))))

  (use-package meow
    :straight t
    :after hydra
    :config
    (add-to-list 'meow-char-thing-table '(?t . tag))
    (meow-thing-register 'tag
                         'meow--tag-find-inner
                         'meow--tag-find-bounds)
    (meow-setup)
    ;; remove those hints that clutter vision
    (setq meow-expand-hint-remove-delay 0)
    (meow-global-mode 1))
#+end_src

** Bindings

Some commands for completing meow, adding the ones I'm used to.

#+begin_src emacs-lisp
  ;; tabs manipulations
  (with-eval-after-load 'general    
    
    ;; Some more complex commands
    (general-define-key
     :keymaps 'meow-normal-state-keymap
     :prefix "%"
     "s" #'scratch-buffer
     "e" #'split-window-below
     "i" #'split-window-right)


    ;; Some more complex commands
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "="
     "=" #'meow-indent
     "t" #'repeat
     "r" #'repeat-complex-command)

    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix ")"
     "n" #'smerge-vc-next-conflict
     "u" #'smerge-keep-upper
     "l" #'smerge-keep-lower
     "b" #'smerge-keep-all
     "r" #'smerge-refine
     "s" #'smerge-resolve)

    
    (general-define-key
     :keymaps 'global-map
     :prefix "C-c f"
     "f" #'ffap
     "s" #'ffap-menu))
#+end_src


* Utilities

** Avy mode

#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :after meow
    :config
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "@"
     "@"  #'avy-goto-char-in-line
     "#"  #'avy-goto-char
     "l d"  #'avy-kill-whole-line
     "l l"  #'avy-goto-end-of-line
     "u"  #'avy-goto-line-above
     "e"  #'avy-goto-line-below
     "l y"  #'avy-copy-line
     "r d"  #'avy-kill-region
     "r y"  #'avy-copy-region
     "r t"  #'avy-transpose-lines-in-region
     "r r"  #'avy-resume
     "r m"  #'avy-move-region)
    (general-define-key
     :prefix "C-z @"
     "@"  #'avy-goto-char-in-line
     "#"  #'avy-goto-char
     "l d"  #'avy-kill-whole-line
     "l l"  #'avy-goto-end-of-line
     "u"  #'avy-goto-line-above
     "e"  #'avy-goto-line-below
     "l y"  #'avy-copy-line
     "r d"  #'avy-kill-region
     "r y"  #'avy-copy-region
     "r t"  #'avy-transpose-lines-in-region
     "r r"  #'avy-resume
     "r m"  #'avy-move-region))
#+end_src

** Windows

There's no unified bindings that permits to manage windows, so here's mine

*** Configuration

#+begin_src emacs-lisp
(winner-mode 1) ;; activate the package that recalls the current layout to redo it
#+end_src

*** windmove

#+begin_src emacs-lisp
  (use-package windmove
    :after meow
    :straight nil
    :config
    (setq windmove-wrap-around t)
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "$"
     "n"  #'windmove-left
     "i"  #'windmove-right
     "e"  #'windmove-down
     "u"  #'windmove-up
     "x"  #'kill-buffer-and-window
     "$" #'delete-window
     "+"  #'balance-windows
     "m"  #'maximize-window
     "s n"  #'windmove-swap-states-left
     "s i"  #'windmove-swap-states-right
     "s e"  #'windmove-swap-states-down
     "s u"  #'windmove-swap-states-up
     "d n"  #'windmove-delete-left
     "d i"  #'windmove-delete-right
     "d e"  #'windmove-delete-down
     "d u"  #'windmove-delete-up)
    )

#+end_src

*** winum mode

Quickly switch between windows

#+begin_src emacs-lisp
  (use-package winum
    :straight t
    :bind (("M-1" . winum-select-window-1)
           ("M-2" . winum-select-window-2)
           ("M-3" . winum-select-window-3)
           ("M-4" . winum-select-window-4)
           ("M-5" . winum-select-window-5)
           ("M-6" . winum-select-window-6)
           ("M-7" . winum-select-window-7)
           ("M-8" . winum-select-window-8))
    :config
    (winum-mode))
#+end_src

** vterm

Vterm is a better terminal emulator that will permit good rendering of all terminal commands

#+begin_src emacs-lisp
  (use-package vterm
    :defer t
    :config
    (setq vterm-kill-buffer-on-exit t)
    (setq vterm-copy-exclude-prompt t))
#+end_src



** EAT

Another terminal emulator

#+begin_src emacs-lisp
  (use-package eat
    :demand t
    :straight (eat :type git
  		 :host codeberg
                      :repo "akib/emacs-eat"
                      :files ("*.el" ("term" "term/*.el") "*.texi"
                              "*.ti" ("terminfo/e" "terminfo/e/*")
                              ("terminfo/65" "terminfo/65/*")
                              ("integration" "integration/*")
                              (:exclude ".dir-locals.el" "*-tests.el")))
    :bind
    ("<f7>" . eat)
    :config
    ;; Better scrollback management
    (setq eat-kill-buffer-on-exit t))
              #+end_src

** Browsing

Calling my edge browser directly from emacs, to save up time

#+begin_src emacs-lisp
  (setq browse-url-generic-program "microsoft-edge-stable")
  (defun smv/browse-search ()
    "Unified search across multiple websites."
    (interactive)
    (let* ((sites '(("Bing" . "https://www.bing.com/search?q=")
                    ("Google" . "https://www.google.com/search?q=")
                    ("YouTube" . "https://www.youtube.com/results?search_query=")
                    ("Wikipedia" . "https://en.wikipedia.org/wiki/Special:Search?search=")
                    ("NixSearch" . "https://search.nixos.org/packages?from=0&size=50&sort=relevance&type=packages&query=")
                    ("Reddit" . "https://www.reddit.com/search/?q=")
                    ("Stack Overflow" . "https://stackoverflow.com/search?q=")
                    ("GitHub" . "https://github.com/search?q=")))
           (site (completing-read "Choose a site: " (mapcar #'car sites)))
           (query (read-string (format "%s search: " site)))
           (url (cdr (assoc site sites))))
      (browse-url-generic (concat url (url-hexify-string query)))))

  (global-set-key (kbd "C-c b") 'smv/browse-search)
#+end_src


** Expand

Permit to expand region quickly, making it less painful to mark some region.

#+begin_src emacs-lisp
  (use-package expand-region
    :straight t
    :config
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     "*" #'er/expand-region)
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "'"
     "o" #'er/mark-outside-pairs
     "i" #'er/mark-inside-pairs
     "u" #'er/mark-url
     "n" #'er/mark-ts-node
     "d" #'er/mark-method-call
     "p" #'er/mark-paragraph
     "'" #'er/mark-inside-quotes
     "\"" #'er/mark-outside-quotes
     "m" #'er/mark-email))
#+end_src


* UI Configuration

** Color Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] and ef  are a set of themes that support various emacs modes. It also has support for doom-modeline that I use as my mode line.

#+begin_src emacs-lisp
  (use-package doom-themes
    :straight t)
  (use-package ef-themes
    :straight t)
  (use-package standard-themes
    :straight t)
  (use-package kaolin-themes
    :straight t
    :config
    (kaolin-treemacs-theme)
    (load-theme 'kaolin-dark))
  (use-package catppuccin-theme
    :straight t)
  (use-package solo-jazz-theme
    :straight t)
  (use-package stimmung-themes
    :straight (stimmung-themes :type git :host github :repo "motform/stimmung-themes" :files ("*.el")))
  (use-package rebecca-theme
    :straight t)

  (use-package pink-bliss-uwu-theme
    :straight (pink-bliss-uwu-theme :type git :host github :repo "themkat/pink-bliss-uwu" :files ("*.el")))
#+end_src

** Adding icons to emacs

You will have to install the icons on your machine before to get the full functionnalities : ~M-x all-the-icons-install-fonts~ , ~M-x nerd-icons-install-fonts~

#+begin_src emacs-lisp
  (use-package all-the-icons
    :straight t
    :if (display-graphic-p))

  (use-package nerd-icons
    :straight t)

  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons)

  ;; to install emoji rendering in emacs
  ;; some external packages to install are : fonts-noto-color-emoji and fonts-emojione on ubuntu
  ;; noto-fonts-emoji and ttf-joypixels on archlinux
  (use-package unicode-fonts
    :straight t
    :config (unicode-fonts-setup))
#+end_src



** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]]  is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix. For example, if you press C-c (hold control and press the letter c), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
  (use-package which-key ;; print next keybindings
    :straight t
    :diminish which-key-mode
    :config ;; only runs after the mode is loaded
    (setq which-key-idle-delay 0.3)
    (which-key-mode))
#+end_src


* Completion system

My completion system, consist on only helm

** Helm

Permit to check the list of things like the pop mark. Pretty neat for me as I prefer visual navigation.

#+begin_src emacs-lisp
  (use-package helm
    :straight t
    :demand t
    :after general
    :bind
    ("M-x" . helm-M-x)
    ("C-s" . helm-occur)
    :config
    (setq helm-mode-fuzzy-match t)
    (setq helm-full-frame nil)
    (setq helm-split-window-inside-p t)
    (setq helm-always-two-windows nil)
    (setq helm-completion-in-region-fuzzy-match t)
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "#"
     "#" #'helm-show-kill-ring
     "i" #'helm-imenu
     "t" #'helm-magit-todos
     "c" #'smv/helm-zoxide-cd)
    (helm-mode)
    :bind
    (
     ("C-x C-f" . helm-find-files)
     ("C-x b" . helm-buffers-list)
     ("C-c h o" . helm-occur-mode)
     ("C-c h c" . smv/helm-zoxide-cd)
     ("C-c h m" . helm-mark-ring)
     ("C-c h k" . helm-show-kill-ring)
     ("C-c h s" . helm-do-grep-ag))
    )
#+end_src


** Navigating between folders

I have zoxide installed on my computer, I want something that will help me quickly switch between the folders I use the most in emacs.

#+begin_src emacs-lisp
  (defun smv/helm-zoxide-candidates ()
    "Generate a list of zoxide query candidates."
    (when-let ((zoxide (executable-find "zoxide")))
      (with-temp-buffer
        (call-process zoxide nil t nil "query" "-l")
        (split-string (buffer-string) "\n" t))))


  (defun smv/zoxide-add-path (path-to-add)
    "Internal helper to add a given PATH-TO-ADD to zoxide.
    Returns t on success, nil on failure."
    (let ((expanded-path (expand-file-name path-to-add)))
      (if (file-directory-p expanded-path)
          (progn
            (call-process (executable-find "zoxide") nil nil nil "add" expanded-path)
            (message "Added '%s' to zoxide." expanded-path)
            t)
        (message "'%s' is not a valid directory." expanded-path)
        nil)))

  (defun smv/zoxide-add-prompt-directory ()
    "Prompt for a directory and add it to zoxide."
    (interactive)
    (if-let ((zoxide (executable-find "zoxide")))
        (let ((dir (read-directory-name "Directory to add to zoxide: " default-directory nil t)))
          (when dir ; User didn't cancel
            (smv/zoxide-add-path dir)))
      (message "zoxide executable not found.")))

  (defun smv/helm-zoxide-source ()
    "Create a Helm source for zoxide directories."
    (helm-build-sync-source "Zoxide Directories"
      :candidates #'smv/helm-zoxide-candidates
      :fuzzy-match t
      :action (helm-make-actions
               "Change Directory" 
               (lambda (candidate)
                 (cd candidate)
                 (message "Changed directory to %s" candidate)))))

  (defun smv/helm-zoxide-cd ()
    "Use Helm to interactively select and change to a zoxide directory."
    (interactive)
    (if (executable-find "zoxide")
        (helm :sources (smv/helm-zoxide-source)
              :buffer "*helm zoxide*")))
#+end_src


** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs’ describe- command buffers. For example, if you use describe-function, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :bind
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

#+end_src


* Org Mode

[[https://orgmode.org/][OrgMode]] is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

** Basic Config

This section contains the basic configuration for org-mode plus the configuration for Org agendas and capture templates

#+begin_src emacs-lisp
  (use-package org ;; org-mode, permit to take notes and other interesting stuff with a specific file extension
    :straight t
    :config
    (setq org-agenda-files
          '("~/.org/todo.org"
            "~/.org/projects.org"))

    (setq org-todo-keywords
          '((sequence "TODO(t!)" "NEXT(n!)" "|" "DONE(d!)")
            (sequence "BACKLOG(b!)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v!)" "WAIT(w@/!)" "|" "COMPLETED(c)" "CANC(k@)")))

    ;; easily move task to another header
    (setq org-refile-targets
          '(("archive.org" :maxlevel . 1)
            ("todo.org" :maxlevel . 1)
            ("projects.org" :maxlevel . 1)
            ("personal.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
          '((:startgroup)
                                          ; Put mutually exclusive tags here
            (:endgroup)
            ("@school" . ?s)
            ("personal" . ?p)
            ("note" . ?n)
            ("idea" . ?i)))

    (setq org-agenda-custom-commands
          '(("d" "Dashboard"
             ((agenda "" ((org-deadline-warning-days 7)))
              (todo "TODO"
                    ((org-agenda-overriding-header "All tasks")))))

            ("n" "Next Tasks"
             ((todo "NEXT"
                    ((org-agenda-overriding-header "Next Tasks")))))
            
            ("a" "Active"
             ((todo "ACTIVE"
                    ((org-agenda-overriding-header "Ongoing Tasks")))))

            ("st" "School todos" tags-todo "+@school/TODO")
            ("sp" "School Projects" tags-todo "+@school/ACTIVE")
            ("sr" "School Review" tags-todo "+@school/REVIEW")

            ("pt" "Personal todos" tags-todo "+personal/TODO")
            ("pl" "Personal Projects" tags-todo "+personal/ACTIVE")
            ("pr" "Personal Review" tags-todo "+personal/REVIEW")
            
            ("oa" "OnePoint Archimind" tags "+archimind+@school+coding/TODO")

            ;; Low-effort next actions
            ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
             ((org-agenda-overriding-header "Low Effort Tasks")
              (org-agenda-max-todos 20)
              (org-agenda-files org-agenda-files)))))

    (setq org-capture-templates ;; quickly add todos entries without going into the file
          `(("t" "Tasks")
            ("tt" "Task" entry (file+olp "~/.org/todo.org" "Tasks")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
            ("ta" "Archimind task" entry (file+regexp "~/.org/todo.org" "PHASE 5")
             "**** TODO %?\n %T\n %a\n %i")))


    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "M-i") 'org-insert-item))

#+end_src




** Org phscroll

Permits to scroll horizontally, this helps in the rendering of tables in org mode.

#+begin_src emacs-lisp
  (use-package phscroll
    :straight (phscroll :type git :host github :repo "misohena/phscroll" :files ("*.el"))
    :after org
    :hook (org-mode . org-phscroll-mode)
    :config
    (setq org-startup-truncated nil))
#+end_src

** Org modern

A package to which I will left all the ricing of my org mode.


#+begin_src emacs-lisp
  (use-package org-modern
    :straight t
    :after org
    :config
    (modify-all-frames-parameters
     '((right-divider-width . 30)
       (internal-border-width . 30)))
    (dolist (face '(window-divider
                    window-divider-first-pixel
                    window-divider-last-pixel))
      (face-spec-reset-face face)
      (set-face-foreground face (face-attribute 'default :background)))
    (set-face-background 'fringe (face-attribute 'default :background))

    (setq
     ;; Edit settings
     org-auto-align-tags nil
     org-tags-column 0
     org-catch-invisible-edits 'show-and-error
     org-special-ctrl-a/e t
     org-insert-heading-respect-content t

     ;; Org styling, hide markup etc.
     org-hide-emphasis-markers t
     org-agenda-tags-column 0
     org-ellipsis "…")

    (global-org-modern-mode))
#+end_src


** Journaling inside emacs


#+begin_src emacs-lisp
  (use-package org-journal
    :defer t
    :after org
    :init
    ;; Set the directory where journal files will be stored
    (setq org-journal-dir "~/.org/journal/")
    ;; Optional: Set a file name format (default is YYYYMMDD)
    (setq org-journal-file-format "%Y-%m-%d.org")
    :bind
    ("C-c n j" . org-journal-new-entry)
    :config
    ;; Optional: Automatically add a timestamp to new entries
    (setq org-journal-enable-timestamp t)
    ;; Straight the directory exists
    (make-directory org-journal-dir t))
#+end_src


** Configure Babel Languages

To execute or export code in org-mode code blocks, you’ll need to set up org-babel-load-languages for each language you’d like to use. [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with org-babel.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (dot . t)
       (python . t)))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))
#+end_src


** Structure Templates

Org mode's [[https://orgmode.org/manual/Structure-Templates.html][structure template]] feature enables you to quickly insert code blocks into your Org files in combination with `org-tempo` by typing `<` followed by the template name like `el` or `py` and then press `TAB`. For example, to insert an empy `emacs-lisp` block below, you can type `<el` and press `TAB` to expand into such a block.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("ru" . "src rust")))

  (add-to-list 'org-structure-template-alist '("cpp" . "src cpp"))
#+end_src


** From org-mode to typst

Typst is a markup language better than latex and org in my point of view due to the customization functionalities that its provide.


#+begin_src emacs-lisp
  (use-package ox-typst
    :straight t
    :defer t
    :after org)
#+end_src




** Convert files using pandoc

Pandoc permits to convert to a variety of documents, so really interesting.
Consult this page for customization : [[https://arnesonium.com/2022/10/org-mode-to-docx-pipeline][Org mode document to different types of files]]

The official repository is : [[https://github.com/emacsorphanage/ox-pandoc][ox-pandoc]]


#+begin_src emacs-lisp
  (use-package ox-pandoc
    :straight t
    :defer t
    :after org)
#+end_src



** Auto-tangle Configuration files

This snippets adds a hook to `org-mode` buffers so that efs/org-babel-tangle-config gets executed each time such a buffer gets saved. This function checks to see if the file being saved is the Emacs.org file you’re looking at right now, and if so, automatically exports the configuration here to the associated output files. Tangle is use to export org mode files into the configuration init.el file.

#+begin_src emacs-lisp

  ;; Automatically tangle our Emacs.org config file when we save it
  (defun smv/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name (format "%s%s" user-emacs-directory "emacs.org")))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'smv/org-babel-tangle-config)))

#+end_src

* Development

** Compilation

#+begin_src emacs-lisp
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
  
  ;; Straight ANSI colors work properly in shell-mode too
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
#+end_src

** Undo tree

Some day undo tree saved my self from losing my progress.

#+begin_src emacs-lisp
  (use-package undo-tree
    :straight t
    :init
    (global-undo-tree-mode)
    :config
    ;; Set a dedicated directory for undo-tree files
    (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    ;; Create the directory if it doesn't exist
    (unless (file-exists-p "~/.emacs.d/undo")
      (make-directory "~/.emacs.d/undo" t)))
  ;; Enable global undo-tree mode
#+end_src

** Terminal Visual Corruption Fixes

Additional fixes for terminal emulator visual corruption issues.

#+begin_src emacs-lisp
  ;; Memory management for all terminal modes
  (setq comint-buffer-maximum-size 5000)
  (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)

  ;; Recovery function when corruption occurs
  (defun smv/fix-terminal-corruption ()
    "Fix visual corruption in terminal buffers."
    (interactive)
    (when (derived-mode-p 'vterm-mode 'eat-mode 'term-mode)
      (recenter)
      (redraw-display)
      (set-char-table-range char-width-table '(#x1fb00 . #x1fbf9) 1)
      (when (derived-mode-p 'vterm-mode)
        (vterm-clear-scrollback))
      (message "Terminal corruption fixes applied")))

  (global-set-key (kbd "C-c t r") 'smv/fix-terminal-corruption)
#+end_src


** Removing pollution from current folder


#+begin_src emacs-lisp
  ;; Store all backup files in a centralized directory
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

  ;; Create the directory if it doesn't exist
  (unless (file-exists-p "~/.emacs.d/backups")
    (make-directory "~/.emacs.d/backups" t))

  ;; Enable auto-save
  (setq auto-save-default t)

  ;; Store all auto-save files in a centralized directory
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

  ;; Create the directory if it doesn't exist
  (unless (file-exists-p "~/.emacs.d/auto-save-list")
    (make-directory "~/.emacs.d/auto-save-list" t))

#+end_src


** Commenting Code

To help me comment code region quickly I set up this keyboard shortcut. The function used is a native emacs function.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-;") 'comment-region)
#+end_src

** Search project wide

wgrep will permit to make grep buffers editable so that you can just modify the occurences of what you're looking for.

I use the built-in rgrep to do my search and replace so I'm binding it to =C-c r=.

#+begin_src emacs-lisp
  (use-package wgrep
    :straight t
    :defer t
    :bind
    ("C-x C-," . wgrep-change-to-wgrep-mode)
    :config
    (global-set-key (kbd "C-c r") 'rgrep))

  ;; Permit to get the first results directly in the compilation buffer
  ;; This kind of buffer is the one used for grep
  (setq compilation-scroll-output 'first-error)

  ;; Ignore some directories
  (eval-after-load 'grep
    '(when (boundp 'grep-find-ignored-directories)
       (add-to-list 'grep-find-ignored-directories "*.git")))
#+end_src

** Lsp-mode

Switching to lsp-mode instead of the default emacs. Lsp-mode has more features than eglot.


#+begin_src emacs-lisp
  (use-package lsp-mode
    :straight t
    :demand t
    :init
    (setq lsp-keymap-prefix "M-l")
    :commands (lsp lsp-deferred)
    :config
    (lsp-enable-which-key-integration t)
    (setq lsp-ui-doc-show-with-mouse nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (general-define-key
     :keymaps 'meow-normal-state-keymap
     :prefix "h"
     "h" #'lsp-ui-doc-toggle
     "q" #'lsp-ui-doc-hide
     "f" #'lsp-ui-doc-focus-frame
     "u" #'lsp-ui-doc-unfocus-frame
     "d" #'lsp-ui-peek-find-definitions
     "e" #'lsp-ui-flycheck-list
     "r" #'lsp-ui-peek-find-references
     "i" #'lsp-ui-peek-find-implementations)
    (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol))

  (use-package lsp-ui
    :straight t
    :after lsp
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode))
#+end_src

** Debugger configuration

Switching to dap-mode because it's more convenient to work with lsp-mode

#+begin_src emacs-lisp
  (use-package dap-mode
    :straight t
    :after (lsp general)
    :custom
    (lsp-enable-dap-auto-configure nil)
    :config
    (dap-ui-mode 1)
    (general-define-key
     :keymaps 'meow-normal-state-keymap
     :prefix "%"
     "d" #'dap-hydra)
    (general-define-key
     :keymaps 'lsp-mode-map
     :prefix lsp-keymap-prefix
     "d" '(dap-hydra t :wk "debugger")))
#+end_src


** Nix

Nix is a package manager and a language that I use to setup devshell or to build my packages in a predictable way.


#+begin_src emacs-lisp
  (use-package nix-mode
    :straight t
    :mode "\\.nix\\'"
    :config
    :hook (nix-mode . lsp-deferred))
#+end_src


** Languages

*** IDE Features with lsp-mode

Language server configuration for programming part.
I use some useful lsp packages with downloaded languages server for my programming journey.

**** Flycheck

This is a better flymake, it has many features. That permits to better see the error and fix them.

#+begin_src emacs-lisp
  (use-package flycheck
    :straight t
    :config
    (setq flycheck-error-list-minimum-level 'error)
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "("
     "(" #'flycheck-buffer
     "d" #'flycheck-disable-checker
     ")" #'flycheck-list-errors)
    )
#+end_src

**** markdown-mode

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t)
#+end_src

**** yasnippet

Useful snippets for quick programming

#+begin_src emacs-lisp
  (use-package yasnippet
    :straight t
    :demand t
    :config
    (yas-global-mode)
    (general-define-key
     :prefix "C-c s"
     "s" #'yas-insert-snippet
     "r" #'yas-reload-all))

  (use-package yasnippet-snippets
    :straight t
    :after yasnippet)
#+end_src

**** auto-yasnippet

A way to create temporary snippet to prevent rewriting code

#+begin_src emacs-lisp
  (use-package auto-yasnippet
    :after general
    :straight t
    :config
    (general-define-key
     :prefix "C-z *"
     "w" #'aya-create
     "x" #'aya-expand
     "h" #'aya-expand-from-history
     "d" #'aya-delete-from-history
     "c" #'aya-clear-history
     "n" #'aya-next-in-history
     "p" #'aya-previous-in-history
     "s" #'aya-persist-snippet
     "o" #'aya-open-line
     ))
  #+end_src

*** Yaml-mode

Mode for yaml configuration files editing.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :straight t
    :defer t
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode)
           ))
#+end_src


*** Java-mode

#+begin_src emacs-lisp
  (use-package lsp-java
    :straight t
    :after lsp
    :hook (java-ts-mode . lsp-deferred))

  (use-package dap-java :defer t :after lsp-java)
#+end_src

*** Web Programming

**** Emmet-mode

Emmet mode allors you to easily expand html and css abbreviations for instance if I type "p" then press control and j I get <p></p>. You can also use things like ~".container>section>(h1+p)"~.

#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :defer t)
#+end_src

**** Web-mode

The useful web mode for programming.

#+begin_src emacs-lisp

  (defun smv/web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-enable-current-column-highlight t)
    (setq web-mode-enable-current-element-highlight t)
    )

  (use-package web-mode
    :straight t
    :defer t
    :mode (("\\.html?\\'" . web-mode)
           ("\\.css?\\'" . web-mode)
           )
    :hook
    (web-mode . smv/web-mode-hook)
    (web-mode . emmet-mode)
    )

  (add-hook 'web-mode-before-auto-complete-hooks
            '(lambda ()
               (let ((web-mode-cur-language
                      (web-mode-language-at-pos)))
                 (if (string= web-mode-cur-language "php")
                     (yas-activate-extra-mode 'php-mode)
                   (yas-deactivate-extra-mode 'php-mode))
                 (if (string= web-mode-cur-language "css")
                     (setq emmet-use-css-transform t)
                   (setq emmet-use-css-transform nil)))))

#+end_src

**** JSX support

#+begin_src emacs-lisp
  (use-package rjsx-mode
    :straight t
    :defer t
    :after prettier
    :mode (("\\.js\\'" . rjsx-mode)
           ("\\.ts\\'" . rjsx-mode))
    :hook
    (rjsx-mode . emmet-mode)
    (rjsx-mode . prettier-mode))
#+end_src

**** prettier

Prettier automatically formats the code for you. I hate when it's in other modes but in web mode it's quite useful.

#+begin_src emacs-lisp
  (use-package prettier
    :straight t
    :defer t
    :after web-mode)
#+end_src



**** Testing rest apis

#+begin_src emacs-lisp
  (use-package restclient
    :straight t
    :defer t
    :mode (("\\.http\\'" . restclient-mode))
    :bind (:map restclient-mode-map
  	      ("C-c C-f" . json-mode-beautify)))
#+end_src

*** RUST

#+begin_src emacs-lisp
  (use-package rust-ts-mode
    :straight t
    :defer t
    :mode "\\.rs\\'"
    :hook (rust-ts-mode . lsp-deferred))
#+end_src

*** Ruby

#+begin_src emacs-lisp
  (use-package ruby-ts-mode
    :straight t
    :defer t
    :mode "\\.rb\\'"
    :hook (ruby-ts-mode . lsp-deferred))
#+end_src

*** Typst-mode

#+begin_src emacs-lisp
  (use-package typst-ts-mode
    :straight t
    :mode "\\.typ\\'")

  (with-eval-after-load 'lsp-mode
    (add-to-list 'lsp-language-id-configuration '(".*\\.typ" . "typst"))

    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection '("tinymist")) ; Or the command to run your LSP server
                      :activation-fn (lsp-activate-on "typst")
                      :server-id 'tinymist)))
#+end_src
*** Dart & flutter

#+begin_src emacs-lisp
  (use-package dart-mode
    :defer t
    :mode "\\.dart\\'"
    :hook (dart-mode . lsp-deferred))

  (use-package lsp-dart
    :defer t
    :after (lsp-mode dart-mode))
#+end_src

*** Dabbrev

Permits buffer completion

#+begin_src emacs-lisp
(use-package dabbrev
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand))
  :config
  (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
  ;; Available since Emacs 29 (Use `dabbrev-ignored-buffer-regexps' on older Emacs)
  (add-to-list 'dabbrev-ignored-buffer-modes 'authinfo-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src



** Cape

A tool that permits to extend the capabilities of completion at point


#+begin_src emacs-lisp
  (use-package cape
    :straight t
    ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
    ;; Press C-c p ? to for help.
    :bind ("M-p" . cape-prefix-map) ;; Alternative key: M-<tab>, M-p, M-+
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    (add-hook 'completion-at-point-functions #'cape-keyword)
    (add-hook 'completion-at-point-functions #'cape-history)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-symbol)
    )
#+end_src





** Orderless

For sorting completion candidates

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :custom
    (orderless-style-dispatchers '(orderless-affix-dispatch))
    (orderless-component-separator #'orderless-escapable-split-on-space)
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))

#+end_src


** Corfu

Corfu provides a nicer in-buffer completion interface than completion-at-point which is more reminiscent of what you would expect from an IDE.
A simple package that permits to get fast completion in emacs.

#+begin_src emacs-lisp

  (use-package corfu
    :straight t
    ;; Optional customizations
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    (corfu-preview-current nil)    ;; Disable current candidate preview
    (corfu-preselect 'prompt)      ;; Preselect the prompt
    (corfu-on-exact-match 'quit)     ;; Configure handling of exact matches
    (corfu-quit-no-match t) ;; quit when there's no match

    ;; Enable Corfu only for certain modes. See also `global-corfu-modes'.
    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    
    :init

    ;; Recommended: Enable Corfu globally.  Recommended since many modes provide
    ;; Capfs and Dabbrev can be used globally (M-/).  See also the customization
    ;; variable `global-corfu-modes' to exclude certain modes.
    (global-corfu-mode)

    ;; Enable optional extension modes:
    (corfu-history-mode)
    (corfu-popupinfo-mode)
    )

#+end_src



** Docker Mode

Quickly manages [[https://github.com/Silex/docker.el][docker]] container directly inside emacs.

#+begin_src emacs-lisp
  (use-package docker
    :defer t
    :bind ("C-c d" . docker))

  (use-package dockerfile-mode
    :after docker)
#+end_src

** Github Copilot

Using github copilot has my pair programming assistant to finish my tasks more quickly.
Uncomment the commented parts only when you will finish installing copilot.

#+begin_src emacs-lisp
  (use-package copilot
    :straight (:type git :host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
    :demand t
    :bind
    (:map copilot-completion-map
          ("C-M-x" . copilot-accept-completion)
          ("C-M-<down>" . copilot-accept-completion-by-word)
          ("C-M-<right>" . copilot-next-completion)
          ("C-M-<left>" . copilot-previous-completion)
          ))
#+end_src


** transient

Some package required for gptel and magit

#+begin_src emacs-lisp
  (use-package transient
    :straight t)
#+end_src


** Direnv

Do not tell me about anything else, direnv is the best package if you want nix to reload your env directly inside emacs.

#+begin_src emacs-lisp
  (use-package direnv
    :straight t)
#+end_src


** AI API

#+begin_src emacs-lisp
  (setenv "GROQ_API_KEY" (with-temp-buffer (insert-file-contents "~/.org/.gq_key") (string-trim (buffer-string))))
  (setenv "ANTHROPIC_API_KEY" (with-temp-buffer (insert-file-contents "~/.org/.ant_key") (string-trim (buffer-string))))
  (setenv "DEEPSEEK_API_KEY" (with-temp-buffer (insert-file-contents "~/.org/.deep_key") (string-trim (buffer-string))))
  (setenv "OPENROUTER_API_KEY" (with-temp-buffer (insert-file-contents "~/.org/.openr_key") (string-trim (buffer-string))))
  (setenv "GEMINI_API_KEY" (with-temp-buffer (insert-file-contents "~/.org/.gem_key") (string-trim (buffer-string))))
#+end_src

** Gptel

Mode to interact with different llms in emacs.

#+begin_src emacs-lisp
  (use-package gptel
    :straight t
    :after general
    :config
    ;; something that makes it more convenient to add mcp tools in gptel
    (require 'gptel-integrations)
    ;; OPTIONAL configuration
    (setq gptel-default-mode 'org-mode)
    (setq gptel-use-context 'user)
    ;; (setq gptel-confirm-tool-calls t)
    (setq gptel-include-tool-results t)
    (setq gptel-include-reasoning nil)
    
    (gptel-make-gemini "Gemini"
      :key (with-temp-buffer (insert-file-contents "~/.org/.gem_key") (string-trim (buffer-string)))
      :stream t)
    (gptel-make-deepseek "DeepSeek"       ;Any name you want
      :stream t                           ;for streaming responses
      :key (with-temp-buffer (insert-file-contents "~/.org/.deep_key") (string-trim (buffer-string))))
    (gptel-make-openai "qwen"
      :host "dashscope-intl.aliyuncs.com"
      :endpoint "/compatible-mode/v1/chat/completions"
      :protocol "https"
      :key (with-temp-buffer (insert-file-contents "~/.org/.qw_key") (string-trim (buffer-string)))
      :models '("qwen3-coder-plus" "qwen-plus-latest"))
    (gptel-make-openai "OpenRouter"
      ;; :online in the language slug to add the search plugin
      :host "openrouter.ai"
      :endpoint "/api/v1/chat/completions"
      :stream t
      :key (with-temp-buffer (insert-file-contents "~/.org/.openr_key") (string-trim (buffer-string)))
      :models '(
  	      perplexity/sonar-pro ;; 3 in - 15 out
  	      anthropic/claude-sonnet-4 ;; 3 in - 15 out
  	      anthropic/claude-sonnet-4.5 ;; 3 in - 15 out
  	      google/gemini-3-pro-preview ;; ;; 2 in - 12 out
  	      openai/gpt-5.1 ;; 1.25 in - 10 out
  	      openai/gpt-5.1-codex ;; 1.25 in - 10 out
  	      google/gemini-2.5-pro ;; 1.25 in - 10 out
  	      openai/gpt-4.1 ;; 2 in - 8 out
  	      qwen/qwen3-coder-plus ;; 1 in - 5 out
  	      anthropic/claude-haiku-4.5 ;; 1 in - 5 out
  	      switchpoint/router ;; 0.85 in - 3.40 out
  	      z-ai/glm-4.6 ;; 0.7 in - 1.75 out
  	      moonshotai/kimi-k2-thinking ;; 0.6 in - 2.5 out
  	      qwen/qwen3-coder  ;; 0.302 in - 0.302 out
  	      minimax/minimax-m1 ;; 0.30 in - 1.65 out
  	      qwen/qwen3-coder-flash ;; 0.3 in - 1.50 out
  	      moonshotai/kimi-dev-72b ;; 0.29 in - 1.15 out
  	      x-ai/grok-code-fast-1 ;; 0.2 in - 1.5 out
  	      minimax/minimax-m2 ;; 0.255 in - 1.02 out
    	      deepseek/deepseek-v3.1-terminus ;; 0.23 in - 0.9 out
  	      google/gemini-2.5-flash-lite ;; 0.10 in - 0.4 out
  	      z-ai/glm-4.5-air:free
  	      qwen/qwen3-coder:free
  	      deepseek/deepseek-chat-v3.1:free
  	      openrouter/sherlock-think-alpha
                ))

    (setq
     gptel-backend (gptel-make-anthropic "Anthropic"
                     :key (with-temp-buffer (insert-file-contents "~/.org/.ant_key") (string-trim (buffer-string)))
                     :stream t))
    
    (gptel-make-gh-copilot "Copilot")

    ;; ;; local models
    (gptel-make-openai "lmstudio"
      :host "127.0.0.1:1234"
      :endpoint "/v1/chat/completions"
      :protocol "http"
      :stream t
      :key "dummy"
      :models '(
  	      qwen/qwen2.5-coder-14b
  	      deepseek-coder-6.7b-instruct
  	      qwen/qwen3-vl-8b
                ))

    ;; loads presets
    (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "command_line" ".el"))
    (general-define-key
     :prefix "&"
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     "l" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "lite_mayuri" ".el")))
     "m" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "mayuri" ".el")))
     "f" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "mayuri_front" ".el")))
     "b" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "mayuri_back" ".el")))
     "r" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "mayuri_reverse_archi" ".el")))
     "d" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "mayuri_designer" ".el")))
     "a" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "architect" ".el")))
     "t" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "tasker" ".el")))
     "k" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "task" ".el")))
     "s" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "summarizer" ".el")))
     "g" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "summarizer_google" ".el")))
     "y" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "yt_script_writter" ".el")))
     "w" (lambda () (interactive) (load-file (format "%s%s/%s%s" user-emacs-directory "presets" "writter" ".el"))))

    ;; configuring the window size
    (add-to-list 'display-buffer-alist
                 `(my-both-modes-active-p
                   (display-buffer-in-side-window)
                   (side . right)
                   (window-width . 0.37)
                   (window-parameters . ((no-other-window . t)))))
    
    (general-define-key
     :keymaps '(meow-normal-state-keymap meow-motion-state-keymap)
     :prefix "!"
     ")" #'gptel-add
     "!" #'gptel-send
     "(" #'gptel)

    (let ((fname (expand-file-name "gptel-gemini-oauth-vertex.el" "~/.org/auth/")))
      (when (file-exists-p fname)
        (load-file fname)
        (gptel-make-gemini-oauth "Gemini-OAuth" :stream t)))
    
    :bind
    ("C-c RET" . gptel-send)
    ("C-c g g" . gptel)
    ("C-c g a" . gptel-abort))

  (use-package gptel-magit
    :straight t
    :after (magit gptel)
    :hook (magit-mode . gptel-magit-install)
    :config
    (load-file (format "%s%s/%s%s" user-emacs-directory "config" "gptel-magit-message" ".el")))
#+end_src

Make gptel work as an agent

#+begin_src emacs-lisp
  (use-package gptel-agent
    :after gptel
    :straight (:host github :repo "karthink/gptel-agent" :files ("*"))
    :config
    (add-to-list 'gptel-agent-dirs (expand-file-name "agents/" user-emacs-directory))
    (gptel-agent-update)
    )
#+end_src


** MCP integration

This permits to add interaction capabilities to my llm. LLMs will be able to use some tools to get more context if needed.

#+begin_src emacs-lisp
  ;; load tools
  ;; (load-file (format "%s%s/%s%s" user-emacs-directory "tools" "fetch_url" ".el"))

  (defun smv-tool/list_projects ()
    "Return a list of full paths to directories in ~/projects/."
    (let ((projects-dir (expand-file-name "~/projects/")))
      (when (file-directory-p projects-dir)
        (seq-filter
         (lambda (path)
           (and (file-directory-p path)
                (not (string-match-p "/\\.\\.?$" path))))
         (directory-files projects-dir t "^[^.]")))))

  (defun smv-tool/project_diagnostics ()
    (let ((buffer nil))
      (unwind-protect
  	(progn
  	  (lsp-ui-flycheck-list)
  	  (setq buffer (buffer-string))
  	  (kill-buffer)
  	  buffer))))

  (defun smv-tool/run_command (command pwd)
    (shell-command-to-string (format "cd %s && %s" pwd command)))

  (defun smv-tool/ask_partner (question)
    "Call gemini given the prompt"
    (let ((command (concat "gemini -p " 
                           (shell-quote-argument question))))
      (shell-command-to-string (format "sleep 5 && %s" command))))

  (defun smv-tool/fetch_url_content (url)
    (smv/fetch-content url))

  (with-eval-after-load 'gptel
    ;; shell command execution tool
    (gptel-make-tool
     :name "run_command"                    ; javascript-style  snake_case name
     :function #'smv-tool/run_command
     :description "Execute a shell command on the system and get the corresponding output. IMPORTANT: ***MAKE SURE TO ALWAYS USE FULL PATHS IF YOUR COMMAND CONTAINS SOME***"
     :confirm t
     :include t
     :args (list '(:name "command"             ; a list of argument specifications
                         :type string
                         :description "The shell command to execute. e.g: echo 'test'")
                 '(:name "pwd"
                         :type string
                         :description "directory from where to execute the command."))
     :category "system")

    (gptel-make-tool
     :name "list_projects"
     :function #'smv-tool/list_projects
     :description "List the paths of the projects that are available on the system"
     :category "project-info")

    (gptel-make-tool
     :name "get_project_diagnostics"
     :function #'smv-tool/project_diagnostics
     :description "List the diagnostics inside the current project (liting errors and others)"
     :category "project-info")

    (gptel-make-tool
     :name "ask_partner"
     :function #'smv-tool/ask_partner
     :description "Get any information from the internet or the current project using natural language. It's like your big brother who knows everything, you call him when you're really stuck, you got no alternative to get info."
     :args (list '(:name "question"             ; a list of argument specifications
                         :type string
                         :description "Your info gathering request. e.g What is the most up to date way of writing slidemasters using pptxgenjs library?"))
     :category "info-gathering")

    (gptel-make-tool
     :name "fetch_url_content"                    ; javascript-style  snake_case name
     :function #'smv-tool/fetch_url_content
     :description "Fetch the content of a web page in text format"
     :confirm t
     :args (list '(:name "url"             ; a list of argument specifications
                         :type string
                         :description "The url of the webpage to fetch. e.g: https://google.com"))
     :category "browsing")

    
    (load-file (format "%s%s/%s%s" user-emacs-directory "tools" "filesystem/filesystem" ".el"))
    )
#+end_src


#+begin_src emacs-lisp
  ;; tools from mcp servers
  (use-package mcp
    :straight (mcp :type git :host github :repo "lizqwerscott/mcp.el" :files ("*.el"))
    :after gptel
    :custom (mcp-hub-servers
             `(
               ("Context7" . (:command "npx" :args ("-y" "@upstash/context7-mcp")))
               ;; playwright install --with-deps # installs browsers in playwright (and their deps) if required
               ("playwright" . (:command "npx" :args ("@playwright/mcp@latest" "--isolated" "--browser" "msedge")))
               ("pyautogui" . (:url "http://172.20.224.1:8000/mcp/"))
               ("sequential-thinking" . (:command "npx" :args ("-y" "@modelcontextprotocol/server-sequential-thinking")))
               ;; ("filesystem" . (:command "npx" :args ("-y" "@modelcontextprotocol/server-filesystem" "~/projects")))
               ))
    :config
    (require 'mcp-hub)
    ;; (add-hook 'after-init-hook
    ;;       (lambda ()
    ;;         (mcp-hub-start-all-server nil '("sequential-thinking"))))
    )
#+end_src





** Agent-shell

A tool that permits to communicate with terminal agents directly from emacs.

#+begin_src emacs-lisp
  (use-package agent-shell
    :straight t
    :defer t
    :config
    (add-to-list 'display-buffer-alist
                 '((major-mode . agent-shell-mode)
  		 (display-buffer-reuse-window display-buffer-in-side-window)
  		 (side . right)
  		 (window-width . 0.37))))
  #+end_src


** Projectile

#+begin_src emacs-lisp
(use-package projectile
  :bind ("C-c p" . projectile-command-map)
  :straight t
  :config
  (projectile-mode))
#+end_src

** Magit

[[https://magit.vc/][Magit]] is a git interface for emacs. It's very handy and fun to use.

#+begin_src emacs-lisp
  (setq project-find-functions 
        (remq 'project-try-vc project-find-functions))

  (use-package magit
    :straight t
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src


** Configuration for ediff

#+begin_src emacs-lisp
  ;; Split windows horizontally for side-by-side comparison
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Split windows horizontally for side-by-side comparison
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src


* EAF

#+begin_src emacs-lisp
  (use-package eaf
    :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
    :config
    (require 'eaf)
    (require 'eaf-markdown-previewer))
#+end_src
