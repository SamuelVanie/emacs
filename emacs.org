#+title: Samuel Michael Vanie's EMACS Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el


* Declare some global variables

#+begin_src emacs-lisp
  (setq gc-const-threshold (* 80 1000 1000))

  (cond
   ((eq system-type 'darwin)  ;; macOS
    (setq read-process-output-max (* 64 1024)))  ;; 64KB
   ((eq system-type 'gnu/linux)  ;; Linux
    (setq read-process-output-max (* 1024 1024)))  ;; 1MB
   )

  ;; You will most likely need to adjust this font size for your system!
  (cond
   ((eq system-type 'darwin)
    (defvar smv/default-font-size 180)
    (defvar smv/default-variable-font-size 180))
   ((eq system-type 'gnu/linux)
    (defvar smv/default-font-size 139)
    (defvar smv/default-variable-font-size 139))
   )

  ;; remove noise for not non allowed command in emacs if your system make them
  (setq ring-bell-function 'ignore)

  (setq custom-file (locate-user-emacs-file "custom-vars.el"))
  (load custom-file 'noerror 'nomessage)

  (setq-default indent-tabs-mode nil)

  ;; auto refresh buffers when files changes
  (global-auto-revert-mode t)
#+end_src

* Scrolling inside popup view

#+begin_src emacs-lisp
  ;; to scroll down inside the popup
  (define-key global-map (kbd "C-M-'")
              (lambda ()
                (interactive)
                (scroll-other-window 2)))

  ;; to scroll up side the popup
  (define-key global-map (kbd "C-M-\"")
              (lambda ()
                (interactive)
                (scroll-other-window-down 2)))

#+end_src

* Package System setup

Emacs has a built in package manager but it doesnâ€™t make it easy to automatically install packages on a new system the first time you pull down your configuration. use-package is a really helpful package used in this configuration to make it a lot easier to automate the installation and configuration of everything else we use.
I don't know why but quelpa doesn't get install automatically (maybe a problem only on mac ?), you should install it manually by running `M-x package-install` then type quelpa

#+BEGIN_SRC emacs-lisp
  ;; Initialize package sources
  (require 'package)
  (require 'cl)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))


  ;; straight.el section
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  (use-package dired-x
    :straight nil
    :config
    (add-hook 'dired-mode-hook #'dired-hide-details-mode)
    (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

  (global-set-key [remap dabbrev-expand] 'hippie-expand)

  (use-package dashboard
    :config
    (dashboard-setup-startup-hook))

  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+END_SRC

* Tree-sitter

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src


* Shell

** Getting the exec path from shell

This is a package that will permit to have the same exec-path as my $PATH shell variable so that all of my packages are available.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
 	(use-package exec-path-from-shell
	    :ensure t
	    :init
	    (exec-path-from-shell-initialize)))
#+end_src

** Eshell Ouptut format

User friendly tool that uses Plan9 style interface to show command outputs. These ones are automatically paginates, making it easier to read and analyse them, particularly when dealing with large amouts of data.

#+begin_src emacs-lisp
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  (setq eshell-list-files-after-cd t)

  ;; Watch out you should have fish installed on your computer
  (setq eshell-aliases-file (format "%s%s" user-emacs-directory "aliases"))
  (setq explicit-shell-file-name "/bin/zsh")

  (use-package eshell-toggle
    :bind ("C-x C-z" . eshell-toggle))
#+end_src

* Buffers

** Managing buffers easily

#+begin_src emacs-lisp
  ;; this will make emacs ibuffer the default used to list buffers
  (defalias 'list-buffers 'ibuffer)
#+end_src

** Kill buffers

I'm writing this function to kill all the buffers because it is really boring to get the confirmation prompt every time you want to kill all the buffers with kill-some-buffers

#+begin_src emacs-lisp
  (defun kill-all-buffers ()
    "Kill all buffers without asking for confirmation."
    (interactive)
    (dolist (buffer (buffer-list))
      (kill-buffer buffer)))

  (global-set-key (kbd "C-c k a") 'kill-all-buffers)
  (global-set-key (kbd "C-k") 'kill-line)
#+end_src


* Basic UI Configuration

This section configures basic UI settings that remove unneeded elements to make Emacs look a lot more minimal and modern.

#+begin_src emacs-lisp

  (scroll-bar-mode -1) ; Disable visible scroll bar
  (tool-bar-mode -1) ; Disable the toolbar
  (tooltip-mode -1) ; Disable tooltips
  (set-fringe-mode 10) ; Give some breathing room
  (menu-bar-mode -1) ; Disable menu bar


  (column-number-mode)
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode t) ;; print line numbers for files


  ;; Set frame transparency
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))



  ;; some modes doesn't have to start with lines enable
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  doc-view-minor-mode-hook
                  shell-mode-hook
                  vterm-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Font Configuration

I use DaddyTimeMono Nerd Font as my main font for both fixed and variable fonts.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (set-frame-font "JetbrainsMono Nerd Font-19" nil t)
    (add-to-list 'default-frame-alist '(font . "JetbrainsMono Nerd Font-15")))
#+end_src

** Ligatures

You will need to install the package ligature, because it cannot be installed automatically. Use the command ~package-install~ and search for ligature.

#+begin_src emacs-lisp
  (use-package ligature
    :config
    ;; Enable all JetBrains Mono ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
                                         "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
                                         "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
                                         "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
                                         "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
                                         "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
                                         ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
                                         "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
                                         "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
                                         "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
                                         "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src

** Adding color to delimiters

Rainbow permits to match pairs delimiters with the same color.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* Keybindings Configuration

** Hydra and general

#+begin_src emacs-lisp
  (use-package hydra) ;; hydra permit to repeat a command easily without repeating the keybindings multiple
  (use-package general) ;; permit to define bindings under another one easily
#+end_src

** Repeat Mode

Allows me te repeat bindings by typing the last character multiple times.

#+begin_src emacs-lisp
  (use-package repeat
    :ensure nil
    :hook (after-init . repeat-mode)
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 5))
#+end_src


** Xah-fly-key

A modal editing tool that permits to avoid emacs' pinky.

#+begin_src emacs-lisp
  (use-package xah-fly-keys
    :init
    (setq xah-fly-use-control-key nil)
    (setq xah-fly-use-meta-key nil)
    :config
    (xah-fly-keys-set-layout "colemak")
    (xah-fly-keys 1)
    :bind
    (:map xah-fly-command-map
          ("/" . nil)))
#+end_src


** Ace-jump mode

#+begin_src emacs-lisp
  (defun smv/custom-ace-jump (mode)
    (interactive
     (list (intern (completing-read "Select mode (char/line/window): "
                                    '("char" "line" "window")
                                    nil t))))
    (xah-fly-insert-mode-activate)
    (pcase mode
      ('char (call-interactively 'ace-jump-char-mode))
      ('line (call-interactively 'ace-jump-line-mode))
      ('window (call-interactively 'ace-window))
      (_ (message "Unknown mode: %s" mode))))


  (use-package ace-jump-mode
    :config
    (general-define-key
     :keymaps 'xah-fly-command-map
     :prefix "/ a"
     "c" (lambda () (interactive) (smv/custom-ace-jump 'char))
     "w" (lambda () (interactive) (smv/custom-ace-jump 'window))
     "l" (lambda () (interactive) (smv/custom-ace-jump 'line))))


#+end_src


* Windows

There's no unified bindings that permits to manage windows, so here's mine

#+begin_src emacs-lisp
  (general-define-key
   :keymaps 'xah-fly-command-map
   :prefix "/ w"
   "n" 'windmove-left
   "i" 'windmove-right
   "e" 'windmove-down
   "u" 'windmove-up
   "+" 'balance-windows
   "m" 'maximize-window)

  (general-define-key
   :keymaps 'xah-fly-command-map
   :prefix "/ w s"
   "n" 'windmove-swap-states-left
   "i" 'windmove-swap-states-right
   "e" 'windmove-swap-states-down
   "u" 'windmove-swap-states-up)
#+end_src

* vterm

Vterm is a better terminal emulator that will permit good rendering of all terminal commands

#+begin_src emacs-lisp
  (use-package vterm)

  (use-package multi-vterm
    :ensure t
    :bind (("C-c v n" . multi-vterm-project)
           ("C-c v f" . multi-vterm)
           ("C-c v r" . multi-vterm-rename-buffer)
           ("C-x C-y" . multi-vterm-dedicated-toggle))
    :config
    (define-key vterm-mode-map [return]                      #'vterm-send-return)
    ;; terminal height percent of 30
    (setq multi-vterm-dedicated-window-height-percent 45))

#+end_src

* UI Configuration

** Color Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] and ef  are a set of themes that support various emacs modes. It also has support for doom-modeline that I use as my mode line.

#+begin_src emacs-lisp
  (use-package doom-themes)
  (use-package ef-themes
    :config (ef-themes-load-random))
#+end_src

** Adding icons to emacs

You will have to install the icons on your machine before to get the full functionnalities : ~M-x all-the-icons-install-fonts~ , ~M-x nerd-icons-install-fonts~

#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))

  (use-package nerd-icons)

  (use-package all-the-icons-dired
    :after all-the-icons)
#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]]  is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix. For example, if you press C-c (hold control and press the letter c), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
  (use-package which-key ;; print next keybindings
    :init (which-key-mode) ;; happens before the package is loaded
    :diminish which-key-mode
    :config ;; only runs after the mode is loaded
    (setq which-key-idle-delay 0.3))
#+end_src


* Completion system

My completion system in emacs includes now : ~Vertico~, ~Orderless~ , ~Marginalia~, ~all-the-icons-completion~ and ~Consult~.


** Vertico

It's a completion interface that is based on the default emacs completion framework.

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    :config
    ;; disable case sensitiveness for files and dir
    (setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      completion-ignore-case t)
    (setq completion-styles '(basic substring partial-completion flex))
    (keymap-set vertico-map "?" #'minibuffer-completion-help)
    (keymap-set vertico-map "M-RET" #'minibuffer-force-complete-and-exit)
    (keymap-set vertico-map "M-TAB" #'minibuffer-complete))
#+end_src

** Marginalia

Permit to add useful information about the current completion candidate.


#+begin_src emacs-lisp
(use-package marginalia
  :custom
  (marginalia-max-relative-age 0)
  (marginalia-align 'right)
  :init
  (marginalia-mode))
#+end_src

** Consult

Permit to check the list of things like the pop mark. Pretty neat for me as I prefer visual navigation.

#+begin_src emacs-lisp
  (use-package consult
    :init
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5)
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :hook (completion-list-mode . consult-preview-at-point-mode)
    :bind
    ("C-s" . consult-line)
    ("M-y" . consult-yank-from-kill-ring)
    ("M-g M-g" . consult-goto-line)
    (:map xah-fly-command-map
          ("/ c f" . consult-fd)
          ("/ c s" . consult-ripgrep)
          ("/ c i" . consult-imenu)
          ("/ c k" . consult-kmacro)
          ("/ c m" . consult-global-mark))
    )
#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacsâ€™ describe- command buffers. For example, if you use describe-function, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :bind
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

#+end_src

** Orderless

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Consult-lsp

Try to mimic the workflow of lsp-ivy

#+begin_src emacs-lisp
  (use-package consult-lsp
    :after (consult lsp-mode)
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))
#+end_src

* Org Mode

[[https://orgmode.org/][OrgMode]] is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

** Better Font Faces

I create a function called `smv/org-font-setup` to configure various text faces for tweaking org-mode. I have fixed font for code source, table, ... and variable font (Roboto Condensed light for text).

#+begin_src emacs-lisp

  (defun smv/org-font-setup ()
    (font-lock-add-keywords 'org-mode ;; Change the list icon style from "-" to "."
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([+]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â—¦"))))))

    ;; configuration of heading levels size
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.0)
                    (org-level-6 . 1.0)
                    (org-level-7 . 1.0)
                    (org-level-8 . 1.0)))
      (set-face-attribute (car face) nil :font "JetbrainsMono Nerd Font" :weight 'regular :height (cdr face)))
    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))

#+end_src

** Basic Config

This section contains the basic configuration for org-mode plus the configuration for Org agendas and capture templates

#+begin_src emacs-lisp

  (defun smv/org-mode-setup()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (auto-fill-mode 0)
    (visual-line-mode 1)
    (smv/org-font-setup))


  (use-package org ;; org-mode, permit to take notes and other interesting stuff with a specific file extension
    :straight org-contrib
    :hook (org-mode . smv/org-mode-setup)
    :config
    (setq org-ellipsis " â–¼:")
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-startup-folded 'content)

    (setq org-agenda-files
          '("~/.org/todo.org"
            "~/.org/projects.org"))

    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
            (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    ;; easily move task to another header
    (setq org-refile-targets
          '(("archive.org" :maxlevel . 1)
            ("todo.org" :maxlevel . 1)
            ("projects.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
          '((:startgroup)
                                          ; Put mutually exclusive tags here
            (:endgroup)
            ("@school" . ?s)
            ("personal" . ?p)
            ("note" . ?n)
            ("idea" . ?i)))

    (setq org-agenda-custom-commands
          '(("d" "Dashboard"
             ((agenda "" ((org-deadline-warning-days 7)))
              (todo "TODO"
                    ((org-agenda-overriding-header "All tasks")))))

            ("n" "Next Tasks"
             ((todo "NEXT"
                    ((org-agenda-overriding-header "Next Tasks")))))

            ("st" "School todos" tags-todo "+@school/TODO")
            ("sp" "School Projects" tags-todo "+@school/ACTIVE")
            ("sr" "School Review" tags-todo "+@school/REVIEW")
            
            ("pt" "Personal todos" tags-todo "+personal/TODO")
            ("pl" "Personal Projects" tags-todo "+personal/ACTIVE")
            ("pr" "Personal Review" tags-todo "+personal/REVIEW")
            
            ;; Low-effort next actions
            ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
             ((org-agenda-overriding-header "Low Effort Tasks")
              (org-agenda-max-todos 20)
              (org-agenda-files org-agenda-files)))))

    (setq org-capture-templates ;; quickly add todos entries without going into the file
          `(("t" "Tasks")
            ("tt" "Task" entry (file+olp "~/.org/todo.org" "Tasks")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)))


    (smv/org-font-setup)
    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "M-i") 'org-insert-item))

#+end_src

** Auto rendering latex section

#+begin_src emacs-lisp
  (use-package org-fragtog
    :hook (org-mode . org-fragtog-mode))
#+end_src

** Presentation

#+begin_src emacs-lisp
  (use-package ox-reveal)
#+end_src

** Nicer Heading

[[https://github.com/sabof/org-bullets][org-bullets]] permits to change the icon used for the different headings in org-mode.

I use also `org-num` to add numbers in front of my different headlines.

#+begin_src emacs-lisp

  (use-package org-bullets ;; change the bullets in my org mode files
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("â—‰" "â˜¯" "â—‹" "â˜¯" "âœ¸" "â˜¯" "âœ¿" "â˜¯" "âœœ" "â˜¯" "â—†" "â˜¯" "â–¶")))

  ;; Outline numbering for org mode
  (use-package org-num
    :straight nil
    :load-path "lisp/"
    :after org
    :hook (org-mode . org-num-mode))
#+end_src

** Configure Babel Languages

To execute or export code in org-mode code blocks, youâ€™ll need to set up org-babel-load-languages for each language youâ€™d like to use. [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with org-babel.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (dot . t)
       (python . t)))
    
    (push '("conf-unix" . conf-unix) org-src-lang-modes))
#+end_src

** Structure Templates

Org mode's [[https://orgmode.org/manual/Structure-Templates.html][structure template]] feature enables you to quickly insert code blocks into your Org files in combination with `org-tempo` by typing `<` followed by the template name like `el` or `py` and then press `TAB`. For example, to insert an empy `emacs-lisp` block below, you can type `<el` and press `TAB` to expand into such a block.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("ru" . "src rust")))

  (add-to-list 'org-structure-template-alist '("cpp" . "src cpp"))
#+end_src

** Auto-tangle Configuration files

This snippets adds a hook to `org-mode` buffers so that efs/org-babel-tangle-config gets executed each time such a buffer gets saved. This function checks to see if the file being saved is the Emacs.org file youâ€™re looking at right now, and if so, automatically exports the configuration here to the associated output files. Tangle is use to export org mode files into the configuration init.el file.

#+begin_src emacs-lisp

  ;; Automatically tangle our Emacs.org config file when we save it
  (defun smv/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name (format "%s%s" user-emacs-directory "emacs.org")))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'smv/org-babel-tangle-config)))

#+end_src

* Development

** Undo tree

Some day undo tree saved my self from losing my progress.

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode))
#+end_src

** Commenting Code

To help me comment code region quickly I set up this keyboard shortcut. The function used is a native emacs function.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-;") 'comment-region)
#+end_src

** Search project wide

wgrep will permit to make grep buffers editable so that you can just modify the occurences of what you're looking for.

I use the built-in rgrep to do my search and replace so I'm binding it to =C-c r=.

#+begin_src emacs-lisp
  (use-package wgrep)
  (global-set-key (kbd "C-c r") 'rgrep)
#+end_src

** Lsp-mode

Switching to lsp-mode instead of the default emacs. Lsp-mode has more features than eglot.


#+begin_src emacs-lisp
  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-l")
    :commands (lsp lsp-deferred)
    :config
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode))

  (use-package lsp-treemacs
    :after lsp)
#+end_src


** lsp-booster

This package permit to make the lsp faster in emacs.
You can install the binary by running =nix-env -iA nixpkgs.emacs-lsp-booster=

#+begin_src emacs-lisp
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

** Nix

Nix is a package manager and a language that I use to setup devshell or to build my packages in a predictable way.


#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'"
    :config
    :hook (nix-mode . lsp-deferred))
#+end_src


** Languages

*** IDE Features with lsp-mode

Language server configuration for programming part.
I use some useful lsp packages with downloaded languages server for my programming journey.

**** Flycheck

This is a better flymake, it has many features. That permits to better see the error and fix them. 

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

**** markdown-mode

#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src

**** yasnippet

Useful snippets for quick programming
#+begin_src emacs-lisp
  (use-package yasnippet
    :config (yas-global-mode))

  (use-package yasnippet-snippets)
#+end_src

**** auto-yasnippet

A way to create temporary snippet to prevent rewriting code

#+begin_src emacs-lisp
  (use-package auto-yasnippet
    :bind
    ("C-c C-y w" . aya-create)
    ("C-c C-y TA". aya-expand)
    ("C-c C-y SP". aya-expand-from-history)
    ("C-c C-y d" . aya-delete-from-history)
    ("C-c C-y c" . aya-clear-history)
    ("C-c C-y n" . aya-next-in-history)
    ("C-c C-y p" . aya-previous-in-history)
    ("C-c C-y s" . aya-persist-snippet)
    ("C-c C-y o" . aya-open-line))
#+end_src

*** Yaml-mode

Mode for yaml configuration files editing.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode)
           ))
#+end_src

*** Web Programming

**** Emmet-mode

Emmet mode allors you to easily expand html and css abbreviations for instance if I type "p" then press control and j I get <p></p>. You can also use things like ~".container>section>(h1+p)"~.

#+begin_src emacs-lisp
  (use-package emmet-mode)
#+end_src

**** Web-mode

The useful web mode for programming.

#+begin_src emacs-lisp

  (defun smv/web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-enable-current-column-highlight t)
    (setq web-mode-enable-current-element-highlight t)
    (set (make-local-variable 'company-backends) '(company-css company-web-html company-yasnippet company-files))
    )

  (use-package web-mode
    :mode (("\\.html?\\'" . web-mode)
           ("\\.css?\\'" . web-mode)
           )
    :hook
    (web-mode . smv/web-mode-hook)
    (web-mode . emmet-mode)
    (web-mode . prettier-mode)
    )

  (add-hook 'web-mode-before-auto-complete-hooks
            '(lambda ()
               (let ((web-mode-cur-language
                      (web-mode-language-at-pos)))
                 (if (string= web-mode-cur-language "php")
                     (yas-activate-extra-mode 'php-mode)
                   (yas-deactivate-extra-mode 'php-mode))
                 (if (string= web-mode-cur-language "css")
                     (setq emmet-use-css-transform t)
                   (setq emmet-use-css-transform nil)))))

#+end_src

**** JSX support

#+begin_src emacs-lisp
  (use-package rjsx-mode
    :mode (("\\.js\\'" . rjsx-mode)
           ("\\.ts\\'" . rjsx-mode))
    :hook
    (rjsx-mode . emmet-mode)
    (rjsx-mode . prettier-mode))
#+end_src

**** prettier

Prettier automatically formats the code for you. I hate when it's in other modes but in web mode it's quite useful.

#+begin_src emacs-lisp
  (use-package prettier)
#+end_src


*** RUST

#+begin_src emacs-lisp
  (use-package rust-mode)

  (use-package rust-ts-mode
    :mode "\\.rs\\'"
    :bind-keymap
    ("C-c c" . rust-mode-map)
    :hook (rust-ts-mode . lsp-deferred))
#+end_src

*** Ruby

clojure-lsp should be installed to use the lsp for this package.

#+begin_src emacs-lisp
  (use-package ruby-ts-mode
    :mode "\\.rb\\'"
    :hook (ruby-ts-mode . lsp-deferred))
#+end_src

** Company Mode

Company Mode provides a nicer in-buffer completion interface than completion-at-point which is more reminiscent of what you would expect from an IDE. We add a simple configuration to make the keybindings a little more useful (TAB now completes the selection and initiates completion at the current location if needed).

#+begin_src emacs-lisp
  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind
    (:map company-mode
          ("M-k" . company-manual-begin))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

  (use-package company-box
    :hook
    (company-mode . company-box-mode))

  (use-package company-tabnine
    :config
    (add-to-list 'company-backends #'company-tabnine t))
#+end_src

** Debugger configuration

Switching to dap-mode because it's more convenient to work with lsp-mode

#+begin_src emacs-lisp
  (use-package dap-mode
    :custom
    (lsp-enable-dap-auto-configure nil)
    :config
    (dap-ui-mode 1)
    (general-define-key
     :keymaps 'lsp-mode-map
     :prefix lsp-keymap-prefix
     "d" '(dap-hydra t :wk "debugger")))
#+end_src

** Docker Mode

Quickly manages [[https://github.com/Silex/docker.el][docker]] container directly inside emacs.

#+begin_src emacs-lisp
  (use-package docker
    :bind ("C-c d" . docker))

  (use-package dockerfile-mode)
#+end_src

** Github Copilot

Using github copilot has my pair programming assistant to finish my tasks more quickly.
Uncomment the commented parts only when you will finish installing copilot.

#+begin_src emacs-lisp
  (use-package copilot
    :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
    :bind
    (:map copilot-completion-map
          ("C-M-<down>" . copilot-accept-completion)
          ("C-M-<up>" . copilot-accept-completion-by-word)
          ("C-M-<right>" . copilot-next-completion)
          ("C-M-<left>" . copilot-previous-completion)
          )
    :ensure t)
#+end_src

** Gptel

Using chatgpt directly in emacs so that I will not be obliged to switch to the web browser when coding.

#+begin_src emacs-lisp
  ;; (defun smv/gptel-api-key ()
  ;;   "Retrieve my OpenAI API key from a secure location."
  ;;   (with-temp-buffer
  ;;     (insert-file-contents-literally "~/.open_api_key")
  ;;     (string-trim (buffer-string))))

  ;; (use-package gptel)
  ;; (setq gptel-api-key (smv/gptel-api-key))
#+end_src

** Youdotcom

This is my own package to make web search and chat directly inside emacs

#+begin_src emacs-lisp
(use-package youdotcom
    :bind
    ("C-c y" . youdotcom-enter)
    :config
    (setq youdotcom-rag-api-key ""))
#+end_src

** Magit

[[https://magit.vc/][Magit]] is a git interface for emacs. It's very handy and fun to use.

#+begin_src emacs-lisp
(use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

